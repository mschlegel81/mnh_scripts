circlePoint(a)->[cos(a),sin(a)];

//f(x)->euklideanNorm(circlePoint(x)-[1,0]);
//plot   (::f            ,0,2*pi,100,'red 2');
//addPlot({f(1.1*$x)/1.1},0,2*pi,100,'blue 2');

TOOTH_OFFSET:=0.15;

gearToothPoints(radius,angle,center:NumericList(2))->begin
  local teeth:=round(radius*6);
  local a:=2*pi/teeth;
  ([0..teeth]-0.25).each(i,[cos(angle+a*i),
                            sin(angle+a*i)]).*(radius).map({$x+center});
end;

fixGearPoint(prevRadius,prevAngle,prevCenter:NumericList(2),
             currRadius,          currCenter:NumericList(2))->begin
  local currAngle:=0;
  local prevPoints:=    gearToothPoints(prevRadius,prevAngle,prevCenter);
  local minDist:={cross(gearToothPoints(currRadius,$newAngle,currCenter),prevPoints).map({$x.agg(-).euklideanNorm}).min};
  local currDist:=minDist(currAngle);
  (2*pi/(currRadius*6)*2^[0..-20]).each(step,begin
    local newDist:=minDist(currAngle+step);
    newDist>currDist
    ? begin
        currAngle+=step;
        currDist:=newDist;
      end
    : begin
        newDist:=minDist(currAngle-step);
        newDist>currDist
        ? begin
            currAngle-=step;
            currDist:=newDist;
          end
        : void;
      end;
  end);
  currAngle;
end;

gear(radius,angle,center:NumericList(2))->begin
  local teeth:=round(radius*6);
  local a:=2*pi/teeth;
  [0..teeth].each(i,[cos(angle+a*i-0.05*a    )*(radius+TOOTH_OFFSET),
                     sin(angle+a*i-0.05*a    )*(radius+TOOTH_OFFSET)],
                    [cos(angle+a*i           )*(radius-TOOTH_OFFSET),
                     sin(angle+a*i           )*(radius-TOOTH_OFFSET)],
                    [cos(angle+a*i+a/2       )*(radius-TOOTH_OFFSET),
                     sin(angle+a*i+a/2       )*(radius-TOOTH_OFFSET)],
                    [cos(angle+a*i+a/2+0.05*a)*(radius+TOOTH_OFFSET),
                     sin(angle+a*i+a/2+0.05*a)*(radius+TOOTH_OFFSET)])
             .leading(3).map({$x+center});
end;


begin
  local radii:=(intRandom(6,12)+1);
  local distances:=((radii.tail|radii.head)+radii);
  local normalizedTargetDistances:=distances/distances.agg(+);
  //First guess for angles will be correct if all radii are equal
  local angles:=[0..radii.size].each(k,distances.head(k).agg(+) orElse 0);
        angles:=angles.leading*2*pi/angles.trailing;
  [1..100].each(step,begin
    //Compute position of points on unit circle
    local points:=angles.map(::circlePoint); points|=points[[0]];
    //Compute relative distances of points on unit circle
    local D:=(points.tail-points.leading).map(::euklideanNorm); D/=D.agg(+);
    //Error is difference to normalizedTargetDistances
    local E:=D-normalizedTargetDistances;
    //Fix the distance with the largest absolute error
    local fixIdx:=E.abs.argMax;
    angles[fixIdx]+=E[fixIdx]*6;
    void;
  end);
  //Gear centers are now fixed:
  local gearCenters:=angles.each(a,circlePoint(a))*distances[0]/euklideanNorm(circlePoint(angles[1])-circlePoint(angles[0]));
  //Gear speeds are inversely prortional to the gear radius
  local speed:=2*pi/6/50/radii*(-1^[0..radii.size-1]);

  begin
    local xy:=gearCenters.each(c,c-radii[index]-TOOTH_OFFSET,
                                 c+radii[index]+TOOTH_OFFSET);
    setOptions(
    ['autoscaleFactor'=>1.0,
     'autoscaleX'=>false,
     'autoscaleY'=>false,
     'axisStyleX'=>0,
     'axisStyleY'=>0,
     'fontsize'=>10.0,
     'logscaleX'=>false,
     'logscaleY'=>false,
     'preserveAspect'=>true,
     'x0'=>xy.getInner(0).min,
     'x1'=>xy.getInner(0).max,
     'y0'=>xy.getInner(1).min,
     'y1'=>xy.getInner(1).max].toMap);
   end;

  //TODO: Fix gear rotation offsets
   local rot:=radii.map({0});
   [1..rot.size-1].each(k,begin
     rot[k]:=fixGearPoint(radii[k-1],rot[k-1],gearCenters[k-1],
                          radii[k],           gearCenters[k]);
   end);


//  clearAnimation;
  [0..49].each(frame,begin
    plot();
    gearCenters.each(gearCenter,gear           (radii[index],speed[index]*frame+rot[index],gearCenter).addPlot('black 2'));
    addAnimationFrame;
    void;
  end);

end;

