memoized fillStyle(phi)->
  ['p fs 0:% GREY'&(max(0.1,min(0.9,0.7-phi*2))),
   'p fs 0:% GREY0.8',
   'p fs 0:% GREY0.7'];


SIZER:=6;

faces:=begin
  local mat:=([0..2]/3*2*pi+0.5)
    .map({[sqrt(2)*cos($a),
           sqrt(2)*sin($a),1]})
    .map({$v/$v.euklideanNorm});
  local rotate:={mat.each(m,$v[index]*m,+)-[0,0,1.077720502487313]};
  local cubeFaces:={begin
  local q:=[$i,$j,-$i-$j];
   [[[0,0,1]+q,[1,0,1]+q,[1,1,1]+q,[0,1,1]+q,[0,0,1]+q].map(rotate)|0,
    [[1,0,0]+q,[1,0,1]+q,[1,1,1]+q,[1,1,0]+q,[1,0,0]+q].map(rotate)|1,
    [[1,1,0]+q,[1,1,1]+q,[0,1,1]+q,[0,1,0]+q,[1,1,0]+q].map(rotate)|2];
   end};
  [-SIZER..SIZER].cross([-SIZER..SIZER])
    .each(ij,cubeFaces(ij[0],ij[1]),|)
    .sort({$x.leading(2).agg(+).euklideanNorm>=
           $y.leading(2).agg(+).euklideanNorm});
end;

plotPoly(proj,L:List,styleIndex)->begin
  local v:=L.map({proj=0 ? $x.head(2) : $x.head(2)*proj*(1/proj+$x[2])});
  v.addPlot(fillStyle(proj)[styleIndex]);
  v.addPlot('black l');
end;

clearAnimation;
setOptions(['axisStyleX'=>0,'axisStyleY'=>0,'autoscaleX'=>false,'x0'=>-4,'x1'=>5,'autoscaleY'=>false,'y0'=>-4,'y1'=>5]);
(0.2*[-50..50]/50).each(phi,
begin
  plot();
  faces
  .each(face,plotPoly(phi,face.leading,face.trailing));
  addAnimationFrame;
  postDisplay;
end);


