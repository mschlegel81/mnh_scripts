USE linAlg;

errorVector(alpha:Numeric,phi0:Numeric,phi1:Numeric,phi2:Numeric,phi3:Numeric)->begin
  local rZ:=rotZ(alpha);
  local A1:=rZ * rotX(phi0) * rZ;
  local A2:=A1 * rotX(phi1) * rZ;
  local A3:=A2 * rotX(phi2) * rZ;
  local A4:=A3 * rotX(phi3) * rZ;
  local d:=[1,0,0]+rZ[0]+A1[0]+A2[0]+A3[0]+A4[0];
  [d.sqr.agg(+)-1,
   rZ[0,0]+d[0],
   rZ[0,0]+(d*A4[0]).agg(+)];
end;

@SuppressUnusedWarning
configSpaceToPictureSpace(alpha:Numeric,phi0:Numeric,phi1:Numeric,phi2:Numeric,phi3:Numeric)->begin
  local rZ:=rotZ(alpha);
  local A1:=rZ * rotX(phi0) * rZ;
  local A2:=A1 * rotX(phi1) * rZ;
  local A3:=A2 * rotX(phi2) * rZ;
  local A4:=A3 * rotX(phi3) * rZ;
  [[0,0,0],
   local p:=[1,0,0],
   p+=rZ[0],
   p+=A1[0],
   p+=A2[0],
   p+=A3[0],
   p+=A4[0],
   [0,0,0]];
end;

PLANES:=
[[0..15].filter({($x and 1)=0}),
 [0..15].filter({($x and 1)=1}),
 [0..15].filter({($x and 2)=0}),
 [0..15].filter({($x and 2)=2}),
 [0..15].filter({($x and 4)=0}),
 [0..15].filter({($x and 4)=4}),
 [0..15].filter({($x and 8)=0}),
 [0..15].filter({($x and 8)=8})];


fourBits(i:Int)->(i and [8,4,2,1]) div [8,4,2,1];

findCubeEndpoints(alpha:Numeric,phi0:Numeric,phi1:Numeric,phi2:Numeric,phi3:Numeric,h:Numeric)->begin
  local errors:=[0..15].each(i,fourBits(i)*h+[phi0,phi1,phi2,phi3])
                       .pMap({errorVector(alpha,$x[0],$x[1],$x[2],$x[3])});
  PLANES.each(plane,errors[plane].getInner(0).sign.unique.size>1 and
                    errors[plane].getInner(1).sign.unique.size>1 and
                    errors[plane].getInner(2).sign.unique.size>1
                    ? errors[plane] : void
                    );
end;

findCubeEndpoints(2*pi/7,0,0,0,0,0.1);
