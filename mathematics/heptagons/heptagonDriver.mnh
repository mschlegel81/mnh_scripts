#!C:\bin\mnh_light.exe -quiet -convertPrintToLog -logDateFmt hh:mm:ss.zzz -logLocationLength 20 +log stdOut(1)
USE curvePartitioning;
curveName(i)->'dc'&i&'.txt';

printMethod(i:Int)->{log(i,' ',$0)};

private calcCurve(i:Int)->begin
  local calcMethod:='d';
  print('Calculating curve: ',i);
  local exitCode:='heptagon.exe'.teeExec([calcMethod,i.toString],printMethod(i),true).trailing;
  exitCode==0
  ? log ('Call heptagon.exe ',calcMethod,' ',i,' stopped with exit code ',exitCode)
  : warn('Call heptagon.exe ',calcMethod,' ',i,' failed with exit code ',exitCode);

  (exitCode==0) AND fileExists(local filename:=curveName(i))
  ? begin
      local lines:=filename.fileLines;
      local granularity:=lines.trim.softCast.filter(::isInt).head(1)[0] orElse fail('No granualarity info found!');
      local samples:=lines.split(',')
                          .trim
                          .softCast
                          .filter((phi)->phi.isNumericList(4))
                          .map(granularity=0 ? ((phi)->phi.map((x)->x<-256 ? x+512 : x>255 ? x-512 : x))
                                             : ((phi)->phi))
                          .unique
                          .each(s,s,-s)
                          .unique;
      deleteFile(filename);
      [i,granularity,samples];
    end
  : false;
end;

POINTS_OF_INTEREST:=[2000,4000,6000,2/3*7000];

private taskIsPending(curveIndex)->curveIndex not in partitionedCurves.getInner(0);

pendingTasks->begin
  local tbc:=unique([2000..2010,5990..6000,4660..4670]|(5*[400..1200])|[2001..2004]|[5996..5999]).minus([4001..4005]).toList;
  tbc[tbc.map((i)->2^(5-trueCount((i mod [1000,500,100,50,10,5])=0))+(abs(i-POINTS_OF_INTEREST).min/200)-32*ord(i in [2001,5999,4010,3500])).sortPerm];
end.filter(::taskIsPending);

outOfOrderMap(parameters:Collection,f:Expression(1))->{begin
  local pending:=map(parameters,(parameter)->future(f,[parameter]));
save;
  pending.size=0
  ? return void
  : void;
  local firstDone:=void;
  local sleepTime:=1E-4;
  while(firstDone.isVoid,firstDone:=pending.each(task,task.peekFuture ? index : void,orElse) orElse sleep(sleepTime:=min(sleepTime*2,10)));
  local result:=pending[firstDone]();
  pending[firstDone]:=void;
  result;
end}.toIteratableExpression;

//*List "missing" curve indexes
main('pending')->pendingTasks.map(::print);

//*Calculate specified curves
main(curveIndex,...)->begin
  assertUniqueInstance;
  changeDirectory(myPath.extractFileDirectory&'/packages');
  files.files(curveName('*')).map(::deleteFile);
  map(curveIndex|...,(par)->try(::toInt,[par],{begin print(helpOnMain); halt; end}))
    .filter((i)->2000<=i<=6000)
    .filter(::taskIsPending)
    .unique
    .outOfOrderMap(::calcCurve)
    .agg((parameters)->parameters.isList(3) ? addPartitionedSamples@parameters : void);
end;

//*Calculate the next 10 pending curves
main->begin
  local pending:=pendingTasks.head(10);
  pending.size==0
  ? print('There are no more pending tasks')
  : main@pending;
end;
