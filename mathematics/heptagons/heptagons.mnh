#!C:\bin\mnh.exe -quiet -logDateFmt hh:mm:ss -logLocationLength 15 +log stdOut(1)
USE curvePartitioning,curveTiming,fourierCurves,visualization;
DEG_120:=2/3*7000;

//Constants for plotRotating
AXIS_X:=0; AXIS_Y:=1; AXIS_Z:=3;
//AXIS_X:=3; AXIS_Y:=0; AXIS_Z:=2;

DOT_STYLES:=['. 0.5 RGB0.5,0,1,0.5',
             '. 0.5 RGB0,0,0,0.5',
             '. 0.5 RGB1,0,0,0.5',
             '. 0.5 RGB0,0.7,0,0.5',
             '. 0.5 RGB0,0,1,0.5'];
CURVE_STYLES:=['RGB0.5,0,1',
               'RGB0,0,0',
               'RGB1,0,0',
               'RGB0,0.7,0',
               'RGB0,0,1'];

//*Plots a partitioned curve
plotRotating(L1:List,L2:List)->begin
  maxNorm:=max(L1.map((part)->part.map(::euklideanNorm).max).max,
               L2.map((part)->part.map(::euklideanNorm).max).max);
  setOptions(["axisStyleX"=>0,"axisStyleY"=>0,
              "autoscaleX"=>false,"autoscaleY"=>false,
              "x0"=>-maxNorm,"x1"=>maxNorm,
              "y0"=>-maxNorm,"y1"=>maxNorm].toMap);
  clearAnimation;
  rangeGenerator(0,99).*(2*pi/100)
  .pMap((tau)->begin
    L1.each(part,begin
      X:=      part.getInner(AXIS_X);
      Y:=      part.getInner(AXIS_Y)*cos(tau)+part.getInner(AXIS_Z)*sin(tau);
      Z:=3/(3-(part.getInner(AXIS_Z)*cos(tau)-part.getInner(AXIS_Y)*sin(tau))/maxNorm);
      [[Y*Z,X*Z].transpose,DOT_STYLES[index mod DOT_STYLES.size]];
    end).|(
    L2.each(part,begin
      X:=      part.getInner(AXIS_X);
      Y:=      part.getInner(AXIS_Y)*cos(tau)+part.getInner(AXIS_Z)*sin(tau);
      Z:=3/(3-(part.getInner(AXIS_Z)*cos(tau)-part.getInner(AXIS_Y)*sin(tau))/maxNorm);
      [[Y*Z,X*Z].transpose,CURVE_STYLES[index mod CURVE_STYLES.size]];
    end));
   end)
  .each(pst,begin
     plot();
     pst.map((row)->addPlot@row);
     addAnimationFrame;
   end);
  display;
end;

@MaxAge=60
memoized writeDataStoresOnceAMinute->begin
  writeDataStores;
  note('Data stores updated');
end;

datastore curveCoefficients:=[].toMap;

getCurveCoefficients(i:Int)->curveCoefficients[i] orElse begin
  assertUniqueInstance;
  samples:=getPartitionedSamples(i);
  coeff:=samples[1].each(sample,begin
    print("\nCalculating curve coefficients ",i,'/',index);
    calcCurveCoeff(sample,i,index,samples[0]).ensureCurveIntegralError(i,false);
  end).sort((x,y)->x['phaseShift']<=y['phaseShift']);
  curveCoefficients[i]:=coeff;
  writeDataStoresOnceAMinute;
  coeff;
end;

//*Calculates all partitioned samples
main->begin
  assertUniqueInstance;
  sortOrScramble:={$L.toList[sortPerm($L.toList.map((i)->abs(i-[2000,4000,4666+2/3,6000]).min))]};
  //sortOrScramble:={$L.toList[sortPerm($L.size.random)]};
  print("╔═════════════════════════════╗\n"&
        "║ Updating curve coefficients ║\n"&
        "╚═════════════════════════════╝\n");

  partitionedCurves.getInner(0).minus(curveCoefficients.getInner(0))
    .sortOrScramble
    .map(::print);
  partitionedCurves.getInner(0).minus(curveCoefficients.getInner(0))
    .sortOrScramble
    .map(::getCurveCoefficients);
  print("╔═════════════════════════════╗\n"&
        "║ Setting planar curves       ║\n"&
        "╚═════════════════════════════╝\n");
  mapToPlanar:={$X.map((data:Map)->begin
    c:=data;
    c[KEY_CURVE]:=0;
    c[KEY_ERROR]:=0;
    c[KEY_KOEFF]:=[0];
    c[KEY_OPTIMIZED]:=true;
    c[KEY_REFCV]:=[false,[[0,[0.0,0.0,0.0,0.0]],[0.5,[0.0,0.0,0.0,0.0]]]].packReferenceCurve;
    c;
  end)};

  curveCoefficients[2001].isVoid ? void : begin
    //planar configuration at 2*pi/7
    curveCoefficients[2000].isVoid OR curveCoefficients[2000].size=0 OR (getCurveCoefficients(2000).getInner(KEY_PHASE)=0).agg(or)
    ? curveCoefficients[2000]:=getCurveCoefficients(2001).mapToPlanar
    : void;
  end;

  curveCoefficients[5999].isVoid ? void : begin
    //planar configuration at 6*pi/7
    curveCoefficients[6000].isVoid OR curveCoefficients[6000].size=0 OR (getCurveCoefficients(6000).getInner(KEY_PHASE)=0).agg(or)
    ? curveCoefficients[6000]:=getCurveCoefficients(5999).mapToPlanar
    : void;
  end;

  curveCoefficients[4000].isVoid OR curveCoefficients[4005].isVoid ? void : begin
    //planar configuration at 4*pi/7
    ((a:=getCurveCoefficients(4000)).getInner(KEY_PHASE)=0).agg(or)
    ? begin
        b:=getCurveCoefficients(4005);
        validA:=a[a.getInner(KEY_PHASE)<>0];
        commonCoeffDist:=(x,y)->euklideanNorm(x.head(min(x.size,y.size))-y.head(min(x.size,y.size)));
        validA|=b.each(bc,[validA.each(ac,ac[KEY_PHASE]==bc[KEY_PHASE]
                                          ? commonCoeffDist(ac[KEY_KOEFF],bc[KEY_KOEFF])
                                          : Inf,min),bc])
                 .sort
                 .trailing(2)
                 .getInner(1)
                 .mapToPlanar;
        curveCoefficients[4000]:=validA;
      end
    : void;
  end;
end;

//*Show a rotating plot for an angle alpha=2*pi/7000 * i
main('show',k)->begin
  assertGuiStarted;
  curveIdx:=k.toInt;
  coefficients:=curveCoefficients[curveIdx];
  coefficients.isVoid
  ? return getPartitionedSamples(curveIdx)[1].plotRotating([])
  : begin
      reconstructed:=coefficients.map(::sampleCurve);
      coefficients.map((c)->c[KEY_REFCV].unpackReferenceCurve[1].map(::trailing))
                  .plotRotating(reconstructed);
    end;
end;

//*Drops a particular curve or all if k='*'
main('drop',...)->
  (...).each(k,
    begin
      k=='*' ? curveCoefficients:=[].toMap :
      curveCoefficients[k.toInt].isVoid
      ? begin
          print('Curve coefficients ',k,' are not present');
          partitionedCurves[k.toInt].isVoid
          ? print('Partitioned curve ',k,' is not present')
          : begin
              ask('Do you really want to drop partitioned curve '&k,['Yes','No'])=='Yes'
              ? partitionedCurves[k.toInt]:=void
              : void;
            end;
        end
      : begin
          curveCoefficients[k.toInt]:=void;
          print('Curve coefficients ',k,' have been dropped');
        end;
    end);

//*Lists the currently available samples
main('list')->begin
  partitionedCurves
    .getInner(0)
    .sort
    .map((c)->format('%s%s',c,isVoid(curveCoefficients[c]) ? ' ' : 'c'))
    .chunkMap(10,(l)->l.join('  '))
    .map(::print)
    .agg(|);
end;

//*Shows a walk through all available values of i (alpha=2*pi/7000 * i)
main('walk',dim1 in ['0'..'3'],dim2 in ['0'..'3'])->begin
  assertGuiStarted;
  clearAnimation;
  d1:=dim1.toInt;
  d2:=dim2.toInt;
  partitionedCurves.getInner(0)
  .sort
  .toIterableExpression
  .pMap((curveIdx)->curveIdx=>(
    curveCoefficients[curveIdx].isVoid
    ? begin
        print('Preparing samples for index ',curveIdx);
        part:=getPartitionedSamples(curveIdx);
        scale:=pi*0.5^(8+part[0]);
        part[1].each(sub,[sub.map({$x[[d1,d2]]*scale}).unique,DOT_STYLES[index]]);
      end
    : begin
        print('Preparing samples and reconstruction for index ',curveIdx);
        curveCoefficients[curveIdx].each(coeff,
        begin
          phase:=coeff[KEY_PHASE];
          [coeff[KEY_REFCV].unpackReferenceCurve[1].map({$x[1,[d1,d2]]}),DOT_STYLES[phase]];
        end,
        begin
          phase:=coeff[KEY_PHASE];
          func:=coeff.getCurveFunction2D(d1,d2);
          t:=max(500,8*(2*coeff[KEY_KOEFF].size+1));
          t:=[0..t]*(2*pi/t);
          [func(t).transpose,CURVE_STYLES[phase]] ;
        end);
      end))
  .each(plottableData,begin
    curveIdxForDisplay:=plottableData[0];
    rowsAndStyles:=plottableData[1];
    plot();
    drawTextAbsolute(0,1,curveIdxForDisplay.toString,20,'TL',[0,0,0],[1,1,1]);
    rowsAndStyles.map((r)->addPlot@r);
    addAnimationFrame;
    index=0 ? display : postDisplay;
  end);
end;

//*Shows an animation of approximated curves
main('walk1D')->begin
  assertGuiStarted;
  clearAnimation;
  setOptions(["preserveAspect"=>false,'fontsize' => 6.0].toMap);

  for curveIndex, curveData in curveCoefficients.sort do parallel begin
    labelText:=format('%s (%s)',curveIndex,curveData.map((coeff)->coeff[KEY_PHASE]).join("/"));
    rowData:=curveData.map((coeff)->begin
      f:=getCurveFunction(coeff,0);
      t:=max(500,coeff.recommendedSampleCount); t:=[0..t]/t*2*pi;
      [[t,f(t)*(180/256)].transpose,CURVE_STYLES[coeff[KEY_PHASE] mod CURVE_STYLES.size]];
    end);
    pointData:=curveData.each(coeff,begin
      [coeff[KEY_REFCV].unpackReferenceCurve[1].each((t,p),[t*2*pi,p[0]*(180/256)]).each((t,p),[t,p],[t+pi,-p]).sort,
       DOT_STYLES[coeff[KEY_PHASE] mod DOT_STYLES.size]];
    end).filter((row,style)->row.size>0);

    [rowData|pointData,labelText];
  end aggregator((frameData)->begin
    plot();
    frameData[0].map((c)->addPlot@c);
    drawTextAbsolute(0,1,frameData[1],12,'TL',[0,0,0],[1,1,1]);
    addAnimationFrame;
    postDisplay;
  end);
end;

barVisualization(X:List,columnWidth:Int)->begin
  validEntries:=X.map((x)->x.isNumeric AND !(x.isNan OR x.isInfinite OR x<=0));
  trueCount(validEntries)<=1 ? return void : void;
  intDig  :=1+floor(ln(X[validEntries].max)/ln(10));
  decimals:=1-floor(ln(X[validEntries].min.max(1E-6))/ln(10));
  while format('%{$0}'&(intDig+decimals+1)&'.'&decimals&"f",X[validEntries]).unique.size<X[validEntries].unique.size/4 do decimals+=1;


  fmt:='%{$0}'&(intDig+decimals+1)&'.'&decimals&"f\v";
  numberLength:=format(fmt,X[validEntries]).join("\n").formatTabs.map(::length).max;
  barLength:=columnWidth-numberLength-1;

  BAR_CELL:=['',"▏","▎","▍","▌","▋","▊","▉","█"];
  @SuppressUnusedWarning = used in format statement
  bar:=(fillFraction:Numeric)->begin
    k:=round(max(0,min(1,fillFraction))*8*barLength);
    repeatString(BAR_CELL[7],k div 8)&BAR_CELL[k mod 8];
  end;

  fmt&='%{bar($0/X[validEntries].max)}s';
  X.each(x,validEntries[index]
           ? format(fmt,x).replace(' ','0')
           : "\v"&(x.isNumeric ? x : void)).join("\n").formatTabs;
end;

//*Shows an info table on existing curves
main('infoTable')->begin
  partIdx:=partitionedCurves.getInner(0);
  coefIdx:=curveCoefficients.getInner(0);


  tabData:=
  [['curve','','sc','#','phase','error','int.Error','opt','cc']].|(
  union(partIdx,coefIdx).sort.pEach(k,
    k in coefIdx
       ? begin
           part :=getPartitionedSamples(k);
           coeff:=curveCoefficients[k];
           coeff.each(subCoeff,
             [k,
              index,
              part[0],
              part[1,subCoeff[KEY_CURVE]].orElse([]).size,
              subCoeff[KEY_PHASE],
              subCoeff[KEY_ERROR],
              subCoeff[KEY_ERROR_INTEGRAL],
              (subCoeff[KEY_OPTIMIZED] orElse false)?'X':'',
              subCoeff[KEY_KOEFF].size,
              isGuiStarted ? subCoeff[KEY_KOEFF].head(20) : void].flatten);
         end
       : k in partIdx
       ? begin
           part:=getPartitionedSamples(k);
           part[1].each(subCurve,[k,index,part[0], subCurve.size]);
         end
       : [k]
  ,|));
  tabData:=tabData.transpose('');
  tabData:=tabData.each(col,
    index in [5,6] ? col.head | col.tail.barVisualization(100)
                   : col);
  tabData:=tabData.transpose('');

  isGuiStarted
  ? begin
      [8..tabData[0].size-1].map((k)->tabData[0,k]:='c_'&(k-8)&'('&((k-8)*2+1)&')');
      showTable(tabData,1,'Info table');
      main('walk1D');
    end
  : tabData.map((row)->row.join("\t")).join("\n").print;
end;

resampleFromPartitioned(curveIndex:Int,coeff:Map)->begin
  partitionedSamples:=getPartitionedSamples(curveIndex);
  scale:=partitionedSamples[0];
  assert(!scale.isVoid);

  partitionedSamples:=partitionedSamples[1,coeff[KEY_CURVE]].pMap((x)->x*0.5^scale/256*pi);
  assert(!partitionedSamples.isVoid);

  reconstructSamples(partitionedSamples,curveIndex,coeff);
end;

private canOptimizeSingleCurve(curveIdx,subCurveIdx)->begin
  assertUniqueInstance;
  coeff  :=getCurveCoefficients(curveIdx)[subCurveIdx];
  coeff[KEY_ERROR]=0 ? return false : void;
  optimized:=
  coeff .optimizeApproximation(curveIdx);
  coeff==optimized OR optimized[KEY_ERROR]>coeff[KEY_ERROR]
  ? begin
      warn('Optimization for ',curveIdx,'/',subCurveIdx,' failed');
      curveCoefficients[curveIdx,subCurveIdx]:=resampleFromPartitioned(curveIdx,coeff);
      writeDataStoresOnceAMinute;
      false;
    end
  : begin
      curveCoefficients[curveIdx,subCurveIdx]:=optimized;
      writeDataStoresOnceAMinute;
      true;
    end;
end;

//*Optimizes the currently worst curve for the given time
main('optimize',timeoutInSeconds)->begin
  pendingFirstRuns:=
    curveCoefficients.each((curveIdx,value),
      value.each(e,(e[KEY_OPTIMIZED] orElse false) ? void : [e[KEY_ERROR],curveIdx,index])
    ,|).sort.reverseList;
  print(pendingFirstRuns.size,' first optimizations are pending');
  pendingFirstRuns.size=0
  ? void
  : pendingFirstRuns.size<10
    ? printf('  %s/%s',pendingFirstRuns.getInner(1),pendingFirstRuns.getInner(2))
    : begin
        printf('  %s/%s',pendingFirstRuns.head(5).getInner(1),pendingFirstRuns.head(5).getInner(2));
        print('  ...');
        printf('  %s/%s',pendingFirstRuns.trailing(5).getInner(1),pendingFirstRuns.trailing(5).getInner(2));
      end;

  timeoutInSeconds.isString AND timeoutInSeconds.copy(0,1) in ['c','C']
  ? begin
      curveIdx:=timeoutInSeconds.copy(1).toInt;
      [0..getCurveCoefficients(curveIdx).size-1].each(subCurveIdx,begin
        print("\nOptimizing curve ",curveIdx,'/',subCurveIdx);
        canOptimizeSingleCurve(curveIdx,subCurveIdx);
      end);
    end
  : begin
      timeout:=scriptTime+timeoutInSeconds.toInt;
      nonoptimizableCurves:=[].toSet;
      while scriptTime<timeout and curveCoefficients.size>0 do begin
        worstEntry:=curveCoefficients
          .each((key,value),value.each(subCoeff,[[!(subCoeff[KEY_OPTIMIZED] orElse false), subCoeff[KEY_ERROR] orElse -Inf],[key,index]]),|)
          .filter((error,curveSpec)->curveSpec not in nonoptimizableCurves)
          .max[1];
        print("\nOptimizing curve ",worstEntry[0],'/',worstEntry[1],'; timeout in ',round(timeout-scriptTime),'s');
        canOptimizeSingleCurve(worstEntry[0],worstEntry[1])
        ? void
        : nonoptimizableCurves||=worstEntry;
      end;
    end;
end;

private discriminator(c:CurveCoefficients)->c[KEY_PHASE]+(c[KEY_PHASE]=3 ? ord(((c[KEY_KOEFF,1] orElse 0)/(c[KEY_KOEFF,0] orElse 1))>0.2) : 0);

private coefficientsByComponent(extractor:Expression)->begin
  dataSets:=
  curveCoefficients.pEach(entry,begin
    k:=entry[0];
    entry[1].each(c,[discriminator(c),k,c]);
  end,|);
  dataSets.map(::tail).group(dataSets.map(::head))
  .each(component,[component[0],component[1].sort.map((c)->[c[0],extractor(c[1])])]).toMap;
end;

//*Shows a plot of the first 3 coefficients
main('coeffPlot')->begin
  assertGuiStarted;
  dataSets:=coefficientsByComponent((c:CurveCoefficients)->c[KEY_KOEFF]);
  setOptions(["preserveAspect"=>false].toMap);
  dataSets.each(set,begin
    style:=CURVE_STYLES[set[0]];
    D:=set[1].union([[DEG_120,[Nan,Nan,Nan,Nan]]]).sort;
    D.map((x)->[x[0],x[1,0] orElse 0]).addPlot(style&' 2');
    D.map((x)->[x[0],x[1,1] orElse 0]).addPlot(style&' 1');
    D.map((x)->[x[0],x[1,2] orElse 0]).addPlot(style&' 0.7');
  end);
  display;
end;

main('animate','walk',componentIndex)->makeWalk(curveCoefficients,componentIndex.toInt,2*pi*random);
main('animate',curveIndex,subCurveIndex)->begin
  assertGuiStarted;
  coeff:=curveCoefficients[curveIndex.toInt,subCurveIndex.toInt] orElse fail('There is no such curve');
  alpha:=curveIndex.toInt*pi/7000;
  animateHeptagon(alpha,coeff);
end;
