USE fourierCurves;
packReferenceCurve  (samples   :Timed4DSamples)->samples.serialize.compress;
unpackReferenceCurve(packedData:String)->packedData.decompress.deserialize;

//*Shifts a list L left periodically by shift
private periodicShift(L:List,shift:Int)->begin
  s:=L.size;
  k:=shift-floor(shift/s)*s;
  k=0
  ? L
  : L.tail(k)|L.head(k);
end;

//*Returns the best guesses for half period index and zero index for a given list l
//*The zero is identified by a symmetry of f(i_0-x)=-f(i_0+x)
//*The half is identified by a symmetry of f(i_1-x)= f(i_1+x)
private findHalfAndZero(l:NumericList)->begin
  judgeSymmetry:=(subList:NumericList)->
    [(subList+subList.reverseList).euklideanNorm,
     (subList-subList.reverseList).euklideanNorm,
     (subList*([0..subList.size-1]-(subList.size-1)/2)).agg(+)];

  I:=[[0..l.size-1],l].transpose[l!=(l.tail|l.head)];
  X:=I.getInner(1);
  I:=[-1|I.getInner(0),I.getInner(0)|l.size-1].transpose.map((idx)->idx[1]==idx[0] ? void : idx[1]<idx[0] ? [idx[0]] : [idx[0]+1..idx[1]]);

  radius:=X.size div 4;
  kernel:=exp(-sqr([-radius..radius]*2/radius));
  symAround:=[0..X.size-1].pMap((i0)->i0|judgeSymmetry(X.periodicShift(i0-radius).head(kernel.size)*kernel));
  bestZero      :=symAround.filter((p)->p[3]>0).sort(1)[0,0];
  validHalfRange:=toSet([bestZero..bestZero+X.size div 3] mod X.size);
  bestHalf      :=symAround.filter((p)->p[0] in validHalfRange).sort(2)[0,0];
  [round(I[bestZero].{$L.agg(+)/$L.size}),
   round(I[bestHalf].{$L.agg(+)/$L.size})];
end;

//*Returns a patch around the index "patchAround"
//*in dimensions [0,1,2] if primary is true and
//*in dimensions [1,2,3] if primary is false
private findLocalPatch(timedCurve:List,patchAround:Int,primary:Boolean)->begin
  samples:=
  map(timedCurve.getInner(1)[(([1..64].each(i,i,-i))+timedCurve.size+patchAround) mod timedCurve.size],
      primary ? ::leading : ::tail);
  point:=samples[0];
  samples:=samples.filter((x)->(x-point).euklideanNorm<=6).toSet;
  primary
  ? [point,samples]
  :        samples;
end;

//*Finds a similar patch in the given timed curve
private findSimilarPatch(timedCurve:List,patchAround:Int,targetTimeIdx)->begin
  referencePatch:=findLocalPatch(timedCurve,patchAround,true);
  referencePoint:=referencePatch[0];
        referencePatch:=referencePatch[1];
  //find points with timing:
  timedPoints:=
    timedCurve.pEach(pt,pt[0].isNan ? void :
      [[index-timedCurve.size,pt[0]-1],
       [index                ,pt[0]  ],
       [index+timedCurve.size,pt[0]+1]],|).sort;
  //Determine scan range:
  I:=[timedPoints[timedPoints.getInner(1)<targetTimeIdx].max[0]+1,
      timedPoints[timedPoints.getInner(1)>targetTimeIdx].min[0]-1];
  (I<0).agg(or) ? I+=timedCurve.size : void;
  ([I[0]..I[1]] mod timedCurve.size).pEach(i,begin
    otherPatch:=findLocalPatch(timedCurve,i,false);
    [union(referencePatch.minus(otherPatch),otherPatch.minus(referencePatch))
     .map((sample)->0.5^(sample-referencePoint).euklideanNorm)
     .agg(+) orElse 0,i];
  end,min)[1];
end;

private timer(message,startTime)->{printf('%-40s (%8.3fs)',message,scriptTime-startTime)};
private timer(message)->timer(message,scriptTime);

timedCurveError(timedSamples:Timed4DSamples,factors:NumericList,phase:Int,doPlotOutput:Boolean)->begin
  assert(!timedSamples.isFullCurve);
  sortedSamples:=timedSamples[1].sort;
//  sortedSamples:=[sortedSamples.head]|zip(sortedSamples.leading,sortedSamples.tail)
//    .each((left,right),(left+right)*0.5,right);

  T:=sortedSamples.getInner(0);
  reconstructed:=sampleCurve(factors,phase,T*2*pi);
  weights:=((T.head(2).agg(-)*-1)|(T.tail(2)-T.leading(2))|(T.trailing(2).agg(-)*-1));
  weights/=weights.agg(+);

  D :=(sortedSamples.getInner(1)-reconstructed).euklideanNorm;
  doPlotOutput
  ? begin
      setOptions(["fontsize"=>6,"preserveAspect"=>false,"x0"=>0,"y0"=>0,"y1"=>1,"autoscaleX"=>true,"autoscaleY"=>true].toMap);
      [T.map(::periodicTime),D].transpose.sort.plot('red 0.5 f');
      addAnimationFrame;
      postDisplay;
    end
  : void;
  (D²*weights).agg(+);
end;

private recommendedFourierCoeffCount(coefficients:NumericList)->ceil((indexOf(coefficients.abs>=coefficients.abs.max*1E-3).max+1)*1.3);

private heptagonExe:=expandedFileName(myPath.extractFileDirectory&'/../packages/heptagon.exe');

private execHeptagonMultiCommand(commandList:StringList)->execHeptagonMultiCommand(commandList,false);
private execHeptagonMultiCommand(commandList:StringList,parseErrorsInsteadOfPositions:Boolean)->begin
  tempFile:='';
  repeat tempFile:=f'temp_{intRandom(9999999)}.txt' until not tempFile.fileExists;
  tempFile.writeFileLines(commandList);
  execOut:=exec(heptagonExe,[tempFile]);
  assert(execOut[1]==0);
  assert(execOut[0].size==commandList.size);
  deleteFile(tempFile);
  parseErrorsInsteadOfPositions
  ? for outputLine in execOut[0] do outputLine.split(";").trailing.replace('*','').trim.split(',').trim.softCast
  : for outputLine in execOut[0] do outputLine.split(";").head    .replace('*','').trim.split(',').trim.softCast;
end;

private improveSingleSample_cmd  (k:Int,phi:NumericList(4))                    ->join('opt'|k|phi,' ');
private getError_cmd             (k:Int,phi:NumericList(4))                    ->join('err'|k|phi,' ');
private findSolutionNearCurve_cmd(k:Int,phi:NumericList(4),dPhi:NumericList(4))->join('dir'|k|phi|dPhi,' ');

truncateCoefficients(dft:NumericList,intPhaseShift:Int,timedCurve:Timed4DSamples)->
  dft.size<=5 ? dft : [dft.size div 2..dft.size].map((k)->min(k,300)).unique.map((k)->dft.head(k)).pEach(subDft,[timedCurveError(timedCurve,subDft,intPhaseShift,false),subDft],min)[1];

thinOutSamples(timedCurve:Timed4DSamples,samplesTarget,maxFractionToDrop)->
  if timedCurve[1].size>samplesTarget then begin
    q:=timedCurve[1].sort;
    gaps:=abs(q.getInner(0).tail(2)-q.getInner(0).leading(2));
    toDropCount:=min(timedCurve[1].size-samplesTarget,round(timedCurve[1].size*maxFractionToDrop));
    toDrop:=gaps.sortPerm.head(toDropCount);
    undroppable:=[].toSet;
    toDrop:=toDrop.each(di,di in undroppable ? void : begin undroppable|=[di-1,di+1]; di; end).head(toDropCount);
    [timedCurve[0],q.each(p,index in toDrop ? void : p)];
  end else timedCurve;

calcCurveCoeff(c:List,curveIndex:Int,subCurveIndex:Int,scale:Int)->
c.size<=8
? [KEY_PHASE=>0,
   KEY_KOEFF=>[0],
   KEY_ERROR=>0,
   KEY_REFCV=>[false,[[0,[0.0,0.0,0.0,0.0]],[0.25,[0.0,0.0,0.0,0.0]]]].packReferenceCurve,
   KEY_CURVE=>subCurveIndex].toMap
: begin
  fileExists(heptagonExe).assert;
  //Symmetries:
  // f_0(t   ) = f_0(T+t   ) = -f_0(  -t) = f_0(T/2   -t)
  //=f_1(t+ a) = f_1(T+t+ a) = -f_1( a-t) = f_1(T/2+ a-t)
  //=f_2(t+2a) = f_2(T+t+2a) = -f_2(2a-t) = f_2(T/2+2a-t)
  //=f_3(t+3a) = f_3(T+t+3a) = -f_3(3a-t) = f_3(T/2+3a-t)
  //a = k/7*T (for integer k)
  //
  //Because of f_0(t) = -f_0(-t) we only need the Sine components of a fourier transform
  //Because of f_0(t) = f_0(T/2-t) we only need the even indexed Sine components of a fourier transform
  //Because of f_0(t) = f_1(t+a) = f_2(t+2a) = f_3(t+3a) we only need one set of coefficients + a phase shift

  //(1) Extract points with exact times from symmetry assumptions:------------
  zerosAndHalves:=c.transpose.map(::findHalfAndZero);
  stepDone:=timer('Symmetry points found in '&c.size&' points');
  phaseShift:=((zerosAndHalves.getInner(0).tail-
                      zerosAndHalves.getInner(0).leading)/c.size)
                   .periodicTime
                   .{($x.agg(+)/$x.size*7).round/7};
  partiallyTimedCurve:=c
    .periodicShift(zerosAndHalves[0,0])
    .head(c.size div 2)
    .map((p)->Nan=>p);
  zerosAndHalves:=(zerosAndHalves+c.size-zerosAndHalves[0,0]) mod c.size;

  partiallyTimedCurve[0,0]:=0;
  partiallyTimedCurve[zerosAndHalves[0,1],0]:=1/4;
  //Assign phase shift timings:
  [1..3].each(dimension,[0..1].each(shiftKind,begin
    shift:=zerosAndHalves[dimension,shiftKind];
    da:=periodicTime(phaseShift*dimension+shiftKind/4);
    shift>=partiallyTimedCurve.size
    ? begin
        shift-=partiallyTimedCurve.size;
        da   -=0.5;
      end
    : void;
    partiallyTimedCurve[shift,0]:=da;
    shift;
  end));
  //Assign phase shift timings:
  [4..6].each(dimension,begin
    zerosAndHalves[dimension]:=[0,0];
    [0..1].each(shiftKind,begin
      fullCurve:=partiallyTimedCurve | partiallyTimedCurve.map((pt)->[pt[0]+0.5,-pt[1]]);
      da:=periodicTime(phaseShift*dimension+shiftKind/4);
      zerosAndHalves[dimension,shiftKind]:=findSimilarPatch(fullCurve,zerosAndHalves[dimension-1,shiftKind],da);
      shift:=zerosAndHalves[dimension,shiftKind];
      shift>=partiallyTimedCurve.size
      ? begin
          shift-=partiallyTimedCurve.size;
          da   -=0.5;
        end
      : void;
      partiallyTimedCurve[shift,0]:=da;
      shift;
    end);
  end);

  stepDone();
  //------------:(1) Extract points with exact times from symmetry assumptions
  //(2) Refine samples:-------------------------------------------------------
  stepDone:=timer('Initial timing ready');
  intPhaseShift:=round(phaseShift*7);
  begin
    tInt:=partiallyTimedCurve.getInner(0).each(t,t.isNan ? void : [index,t]).newLinearInterpolator;
    partiallyTimedCurve:=[false,partiallyTimedCurve.pEach((t,p),tInt(index)=>p*0.5^scale/256*pi)];
  end;

  joinedCurve:=[0..3].each(dim,partiallyTimedCurve[1].getInner(1).each(x,(index/partiallyTimedCurve[1].size*0.5- phaseShift*dim)=>x[dim]),|);
  isGuiStarted ? begin
    setOptions(["fontsize"=>6,"preserveAspect"=>false].toMap);
    joinedCurve.sort.plot('black 0.5 l');
    map([0..3],(dim)->partiallyTimedCurve[1].getInner(1).each(x,(index/partiallyTimedCurve[1].size*0.5- phaseShift*dim)=>x[dim]).addPlot('0.5 .'));
    addAnimationFrame;
  end : void;
  timedCurve:=[false,partiallyTimedCurve[1].filter((t,x)->not t.isNan).sort];
  //-------------------------------------------------------:(2) Refine samples
  //(3) Interpolation of time:------------------------------------------------
  PLOT_INTERMEDIATE:=isGuiStarted
  ? (dft,_4DSamples)->begin
      setOptions(["fontsize"=>6,"preserveAspect"=>false].toMap);
      plot();
      map([0..3],(dim)->_4DSamples.map((pt)->periodicTime(pt[0]- phaseShift*dim)=>pt[1,dim]).sort.addPlot('0.5 . black'));
      f:=getCurveFunction([KEY_PHASE=>intPhaseShift,KEY_KOEFF=>dft].toMap,0);
      addPlot((t)->f(t*2*pi),0,1,5000,'red');
      addAnimationFrame;
      display;
    end
  : (dft,_4DSamples)->void;

  stepDone:=timer('Find initial Fourier series');
  dft:=[0..3].each(k,timedCurve[1].each((t,p),periodicTime(t-k*phaseShift)=>p[k])
                                  .each((t,p),[t,p],[periodicTime(t+0.5),-p]),|)
             .sort
             .getInner(1)
             .calculateFourierCoefficients(16*2+1)
             .each((re,im),(index and 1)=1 ? im : void);

  [1..dft.size].map((k)->dft.head(k)).pEach(C,begin
    E:=curveIntegralError(C,curveIndex,intPhaseShift);
    E=>C;
    end,min)[1];

  PLOT_INTERMEDIATE(dft,timedCurve[1]);
  stepDone();

  if phaseShift>0.5 then begin
    phaseShift:=1-phaseShift;
    intPhaseShift:=round(phaseShift*7);
  end;

  bestDft:=dft;
  bestError:=curveIntegralError(dft,curveIndex,intPhaseShift);
  //timedCurveError(timedCurve,dft,intPhaseShift,false);
  bestTiming:=timedCurve;
  printf('  %5s samples; %3s coefficients; error´%16.10f - phase: %spi/7',timedCurve[1].size,dft.size,bestError,intPhaseShift);

  stepDone:=timer('Timing interpolated');
  //Initial Timing
  begin
    k:=max(1024,timedCurve[1].size);
    T:=[0..k-1]/k;
    samples:=transpose(f4(dft,intPhaseShift)(T*2*pi));
    partiallyTimedCurve:=
    newTimedCurve:=[timedCurve[0],partiallyTimedCurve[1].pMap((t,p)->[T[transpose(p-samples).euklideanNorm.argMin],p])];
    dft:=splineFourierTransform(newTimedCurve,phaseShift,min(k div 4,dft.size)).truncateCoefficients(intPhaseShift,newTimedCurve);

    newError:=curveIntegralError(dft,curveIndex,intPhaseShift);
    PLOT_INTERMEDIATE(dft,newTimedCurve[1]);

    printf('  %5s samples; %3s coefficients; error´%16.10f%s',newTimedCurve[1].size,dft.size,newError,newError<bestError ? ' *' :'');
    bestError :=newError;
    bestTiming:=timedCurve:=newTimedCurve.retimeCurveByFourierCoeff(dft,intPhaseShift,false)['timedSamples']
                                         .thinOutSamples(recommendedSampleCount(dft),0.1);
  end;
  stepDone();

  stepDone:=timer('Initial fitting ready');
  errorGrows:=0;
  repeat
    dft:=splineFourierTransform(timedCurve,phaseShift,
                                dft.recommendedFourierCoeffCount)
         .truncateCoefficients(intPhaseShift,timedCurve);
    timedCurve:=timedCurve.retimeCurveByFourierCoeff(dft,intPhaseShift,false)['timedSamples']
                          .thinOutSamples(recommendedSampleCount(dft),0.1);

    PLOT_INTERMEDIATE(dft,timedCurve[1]);
    curveError:=curveIntegralError(dft,curveIndex,intPhaseShift);
    printf('  %5s samples; %3s coefficients; error´%16.10f%s',timedCurve[1].size,dft.size,curveError,curveError<bestError ? curveError<bestError*0.9 ? ' **' : ' *' :'');

    if curveError<bestError then begin
      if curveError<bestError*0.9
      then errorGrows:=0
      else errorGrows+=1;
      bestError :=curveError;
      bestTiming:=timedCurve;
      bestDft   :=dft;
    end else errorGrows+=1;
  until (errorGrows>10);

  timedCurve:=bestTiming;
  error     :=bestError:=timedCurveError(timedCurve,dft,intPhaseShift,false);
  dft       :=bestDft;

  stepDone();
//  result:=
  [KEY_PHASE=>intPhaseShift,
   KEY_KOEFF=>bestDft,
   KEY_ERROR=>error,
   KEY_REFCV=>timedCurve.packReferenceCurve,
   KEY_CURVE=>subCurveIndex].toMap;
//  didResampling:=false;

  stepDone:=timer('Timing refinement');
  errorGrows:=0;
  repeat
    dft:=splineFourierTransform(timedCurve,phaseShift,dft.recommendedFourierCoeffCount)
         .truncateCoefficients(intPhaseShift,timedCurve);
    timedCurve:=timedCurve.retimeCurveByFourierCoeff(dft,intPhaseShift,false)['timedSamples']
                          .thinOutSamples(recommendedSampleCount(dft),0.1);

    PLOT_INTERMEDIATE(dft,timedCurve[1]);
    error:=timedCurveError(timedCurve,dft,intPhaseShift,false);
    printf('  %5s samples; %3s coefficients; error %16.10f%s',timedCurve[1].size,dft.size,error,error<bestError ? error<bestError*0.99 ? ' **' : ' *' :'');

    if error<bestError then begin
      if error<bestError*0.99
      then errorGrows:=0
      else errorGrows+=1;
      bestError :=error;
      bestTiming:=timedCurve;
      bestDft   :=dft;
    end else errorGrows+=2;
  until errorGrows>32;
  stepDone();
  //------------------------------------------------:(3) Interpolation of time
  [KEY_PHASE=>intPhaseShift,
   KEY_KOEFF=>bestDft,
   KEY_ERROR=>bestError,
   KEY_REFCV=>bestTiming.packReferenceCurve,
   KEY_CURVE=>subCurveIndex,
   KEY_OPTIMIZED=>false].toMap.resample(curveIndex,true,true);
end;

curveIntegralError(coefficients:NumericList,curveIndex:Int,phase:Int)->begin
  sampleCount:=recommendedSampleCount(coefficients);

  errors:=
  sampleCurve(coefficients,
              phase,
              [0..sampleCount-1]/sampleCount*pi)
  .map((phi)->getError_cmd(curveIndex,phi))
  .execHeptagonMultiCommand(true);
  errors.euklideanNorm.sqr.agg(+)/errors.size;
end;

ensureCurveIntegralError(coeff:CurveCoefficients,curveIndex:Int,force:Boolean)->if coeff[KEY_ERROR_INTEGRAL].isVoid or force then begin
  log('Updating curve integral error for curve ',curveIndex,'/',coeff[KEY_CURVE] orElse fail);
  [KEY_ERROR_INTEGRAL=>curveIntegralError(coeff[KEY_KOEFF] orElse fail,curveIndex,coeff[KEY_PHASE] orElse fail)]
  .toMap
  .mergeMaps(coeff,::orElse);
end else coeff;

optimizeApproximation(coeff:CurveCoefficients,curveIndex:Int)->begin
  timedCurve  :=(coeff[KEY_REFCV] orElse fail).unpackReferenceCurve;
  phaseShift  := coeff[KEY_PHASE] orElse fail('Missing key: ',KEY_PHASE);
  initialError:= coeff[KEY_ERROR] orElse fail('Missing key: ',KEY_ERROR);
  coefficients:= coeff[KEY_KOEFF] orElse fail;

  timedCurveHistory    :=[timedCurve,timedCurve];
  curveParameterHistory:=[coefficients,coefficients];
  errorHistory         :=[Inf,initialError];
  movementHistory      :=[Inf,Inf];

  firstOptimizationRun:=!(coeff[KEY_OPTIMIZED] orElse false);
  errorThreshold:=initialError*0.5;
  print ('  Curve samples: ',timedCurve[1].size);
  printf('  Init. error : %16.10f (%5.1f%%); coeffCount: %3d%s',
         initialError,
         initialError/errorThreshold*100-100,
         coefficients.size,
         firstOptimizationRun ? ' (first run)' : '');
  historyPush:=(newTimedCurve:List,newParameters:NumericList,newError:Numeric,newMovement:Numeric)->begin
    timedCurveHistory    ||= newTimedCurve;
    curveParameterHistory||= newParameters;
    errorHistory         ||= newError;
    movementHistory      ||= newMovement;
  end;

  shrinksBy:=(list:NumericList,factor:Numeric)->list.size<2 ? true : begin
    trail:=list.trailing(2);
    (trail.isNan or trail.isInfinite).agg(or)
    ? true
    : trail[1]<trail[0]*factor;
  end;
  intermediateError:=initialError;
  invalidCoefficientsFound:=false;
  runsSinceResampling:=0;
  maxRunsSinceResampling:=10;

  while errorHistory.trailing>errorThreshold do begin
    timedCurveHistory    |=[timedCurve,timedCurve];
    curveParameterHistory|=[coefficients,coefficients];
    errorHistory         |=[Inf,intermediateError];
    movementHistory      |=[Inf,Inf];

    if  firstOptimizationRun then errorThreshold:=max(initialError,errorThreshold);

    while !invalidCoefficientsFound AND movementHistory.shrinksBy(0.95) AND errorHistory.shrinksBy(0.99) do begin
      coefficients:=splineFourierTransform(timedCurve,phaseShift/7,coefficients.recommendedSampleCount).truncateCoefficients(phaseShift,timedCurve);

      //Handle denormalized coefficients:
      !coefficients.isNan.agg(or) and !coefficients.isInfinite.agg(or)
      ? begin
          retimeOut:=timedCurve.retimeCurveByFourierCoeff(coefficients,phaseShift,true);
          timedCurve:=retimeOut['timedSamples'];
          movement  :=retimeOut['maxTimeDelta'];
          historyPush(timedCurve,coefficients,timedCurveError(timedCurve,coefficients,phaseShift,isGuiStarted),movement);
          printf('  Curve error : %16.10f (%5.1f%%); coeffCount: %3d; moving by: %12.4e',
            errorHistory.trailing,
            errorHistory.trailing/errorThreshold*100-100,
            coefficients.size,
            movement);
          if (runsSinceResampling+=1)>maxRunsSinceResampling OR not(recommendedSampleCount(coefficients)*0.6<timedCurve[1].size<recommendedSampleCount(coefficients)*1.5)
          then begin
            k:=argMin(errorHistory);
            resampledCoeff:=
              [KEY_REFCV=>packReferenceCurve(timedCurveHistory[k]),
               KEY_KOEFF=>curveParameterHistory[k],
               KEY_OPTIMIZED=>true,
               KEY_ERROR=>errorHistory.trailing].toMap.mergeMaps(coeff,::orElse).resample(curveIndex,true,true);
            timedCurve       :=resampledCoeff[KEY_REFCV].unpackReferenceCurve;
            coefficients     :=resampledCoeff[KEY_KOEFF];
            intermediateError:=resampledCoeff[KEY_ERROR];

            retimeOut:=timedCurve.retimeCurveByFourierCoeff(coefficients,phaseShift,true);
            timedCurve:=retimeOut['timedSamples'];
            movement  :=retimeOut['maxTimeDelta'];
            historyPush(timedCurve,coefficients,timedCurveError(timedCurve,coefficients,phaseShift,isGuiStarted),movement);
            runsSinceResampling:=0;
          end;
        end
      : begin
          warn('Invalid coefficients encountered: ',coefficients);
          invalidCoefficientsFound:=true;
          //error threshold set to infinity
          errorThreshold:=Inf;
          //Log infinite error and infinite movement!
          historyPush(timedCurve,coefficients,Inf,Inf);
        end;
    end;
    intermediateError:=min(errorHistory);
    k:=argMin(errorHistory);
    timedCurve  :=timedCurveHistory[k];
    coefficients:=curveParameterHistory[k];
    //Increase error tolerance to limit loop count
    errorThreshold*=1.01;
  end;

  printf('  Final error : %16.10f         ; coeffCount: %3d',intermediateError,coefficients.size);

  intermediateError>=initialError AND !firstOptimizationRun
  ? coeff
  : [KEY_REFCV=>packReferenceCurve(timedCurve),
     KEY_KOEFF=>coefficients,
     KEY_OPTIMIZED=>true,
     KEY_ERROR=>intermediateError].toMap.mergeMaps(coeff,::orElse).ensureCurveIntegralError(curveIndex,true);
end;

resample(coeff:CurveCoefficients,curveIndex:Int,forceResampling:Boolean,updateCoefficients:Boolean)->begin
  coefficients:=coeff[KEY_KOEFF] orElse fail;
  samplesRequired:=recommendedSampleCount(coeff);
  currentSamples:=coeff[KEY_REFCV].unpackReferenceCurve[1].size;
  !forceResampling AND (samplesRequired*0.6<currentSamples<samplesRequired*1.5 OR coeff[KEY_ERROR]=0)
  ? return coeff
  : print('Resampling curve...');
  done:=timer('Resampling');

  phaseShift  := coeff[KEY_PHASE] orElse fail;
  T:=[0..samplesRequired-1]/samplesRequired*0.5;
  print("  Samples before\t",coeff[KEY_REFCV].unpackReferenceCurve[1].size,"\n",
        "  Resampling curve at\t",T.size,"\tpoints");
  print('  Error before resampling : ',coeff[KEY_ERROR] orElse fail);

  timedCurve:=[false,
               zip(sampleCurve  (coefficients,phaseShift,T*2*pi),
                   sampleCurveDt(coefficients,phaseShift,T*2*pi))
               .each((phi,dPhi),findSolutionNearCurve_cmd(curveIndex,phi,dPhi))
               .execHeptagonMultiCommand
               .zip(T)
               .each((phi,t),[t,phi])];

  //timedCurve:=[false,
  //  sampleCurve(coefficients,phaseShift,T*2*pi).pEach(x,
  //    [T[index],improveSingleSample(curveIndex,x)])];
  if updateCoefficients
  then coefficients:=splineFourierTransform(timedCurve,phaseShift/7,coefficients.recommendedSampleCount).truncateCoefficients(phaseShift,timedCurve);
  timedCurve:=timedCurve.retimeCurveByFourierCoeff(coefficients,phaseShift,true)['timedSamples'];

  error:=timedCurve.timedCurveError(coefficients,phaseShift,isGuiStarted);
  print('  Error after  resampling : ',error);

  done();
  result:=
  [KEY_REFCV=>packReferenceCurve(timedCurve),
   KEY_KOEFF=>coefficients,
   KEY_OPTIMIZED=>true,
   KEY_ERROR=>error].toMap.mergeMaps(coeff,::orElse);

  if updateCoefficients and not(samplesRequired*0.6<currentSamples<samplesRequired*1.5)
  then result.resample(curveIndex,forceResampling,updateCoefficients)
  else result;
end;

reconstructSamples(c:List,curveIndex:Int,coeff:Map)->begin
  currentCurve:=sampleCurve(coeff);
  error:=coeff[KEY_ERROR];
  coefficients:=coeff[KEY_KOEFF];
  T:=[0..currentCurve.size-1]/currentCurve.size;

  log('Timing ',c.size,' discrete samples');
  samples:=
    c.pMap((x)->begin closest:=currentCurve.map((r)->euklideanNorm(r-x)).argMin; T[closest]=>x; end)
     .filter((pt)->0<=pt[0]<=0.5);
  log('Refining ',samples.size,' samples');
  samples.map((_,p)->improveSingleSample_cmd(curveIndex,p))
         .execHeptagonMultiCommand
         .zip(samples.getInner(0))
         .map((p,t)->[t,p]);
  samples:=[false,samples].retimeCurveByFourierCoeff(coefficients,coeff[KEY_PHASE],true)['timedSamples'];
  printf('      Initial error : %16.10f; coeffCount: %3d',error,coefficients.size);
  [1..16].each(i,begin
    coefficients:=splineFourierTransform(samples,coeff[KEY_PHASE]/7,max(coefficients.size,recommendedFourierCoeffCount(coefficients)));
    samples:=samples.retimeCurveByFourierCoeff(coefficients,coeff[KEY_PHASE],true)['timedSamples'];
    coefficients:=coefficients.truncateCoefficients(coeff[KEY_PHASE],samples);
    samples:=samples.thinOutSamples(2*(coefficients.size*2+1),0.1);

    printf(' #%2d/16 Curve error : %16.10f; coeffCount: %3d',
           i,
           error:=timedCurveError(samples,coefficients,coeff[KEY_PHASE],isGuiStarted),
           coefficients.size);
  end);

  [KEY_REFCV=>packReferenceCurve(samples),
   KEY_ERROR=>error,
   KEY_KOEFF=>coefficients,
   KEY_OPTIMIZED=>true].toMap.mergeMaps(coeff,::orElse);
end;
