USE fourierCurves;

STYLES:=map([0..200]/200,(x)->'. 0.5 GREY'&x);

@SuppressUnusedParameterWarning
type Matrix(L:NumericList(9))->true;
OPERATOR_MULT(x:Matrix,y:Matrix)->
  [x[0]*y[0]+x[1]*y[3]+x[2]*y[6],
   x[0]*y[1]+x[1]*y[4]+x[2]*y[7],
   x[0]*y[2]+x[1]*y[5]+x[2]*y[8],
   x[3]*y[0]+x[4]*y[3]+x[5]*y[6],
   x[3]*y[1]+x[4]*y[4]+x[5]*y[7],
   x[3]*y[2]+x[4]*y[5]+x[5]*y[8],
   x[6]*y[0]+x[7]*y[3]+x[8]*y[6],
   x[6]*y[1]+x[7]*y[4]+x[8]*y[7],
   x[6]*y[2]+x[7]*y[5]+x[8]*y[8]].toMatrix;
private rx(alpha:Numeric)->
   [1, 0         , 0         ,
    0, cos(alpha),-sin(alpha),
    0, sin(alpha), cos(alpha)].toMatrix;
private rz(alpha:Numeric)->
  [cos(alpha),-sin(alpha), 0,
   sin(alpha), cos(alpha), 0,
   0,          0,          1].toMatrix;

private reconstructPoints(alpha:Numeric,phi:NumericList(4))->begin
  local d:=[[1,0,0]];
  local rotZ:=rz(alpha);
  local a:=rotZ;        d ||=a[[0,3,6]];
  a:=a*rx(phi[0])*rotZ; d ||=a[[0,3,6]];
  a:=a*rx(phi[1])*rotZ; d ||=a[[0,3,6]];
  a:=a*rx(phi[2])*rotZ; d ||=a[[0,3,6]];
  a:=a*rx(phi[3])*rotZ; d ||=a[[0,3,6]];
  local x:=[0,0,0];
  x:=[[0,0,0]]|d.each(edge,x+=edge);
end;

private plot3DPoly(points:List)->begin
  local t:=points|points.head(2);
  local points:=
  [t.leading(2),t.leading.tail,t.tail(2)].transpose.pEach(triplet,begin
    local x0:=triplet[0];
    local x1:=triplet[1];
    local x2:=triplet[2];
    local a:=(x0-x1);  a/=a.euklideanNorm;
    local b:=(x2-x1);
    local alpha:=arccos((b*a).agg(+)/b.euklideanNorm);
    b-=(b*a).agg(+)*a;
    b/=b.euklideanNorm;

    ([0..299]/300).each(w,x0*(1-w)+x1*w)|
    ([0..50]/50*alpha).each(phi,x1+b*0.1*sin(phi)+a*0.1*cos(phi));
  end,|);

  local perspectivity:=0.5;
  local xy:=points.map(::leading);
  local z:=points.getInner(2);
  local factor:=1/(z-1*(1/perspectivity+1))/perspectivity*0.95*(1+perspectivity);
  xy*=factor;
  z:=round((z+1)/2*STYLES.size).map((q)->min(200,max(0,q)));

  setOptions(["x0"=>-1,"x1"=>1,"y0"=>-1,"y1"=>1,"autoscaleX"=>false,"autoscaleY"=>false,"axisStyleX"=>0,"axisStyleY"=>0].toMap);
  plot();
  group(xy,z).sort.each(g,addPlot(g[1],STYLES[200-g[0]]));
end;

plotHeptagon(alpha:Numeric,phi:NumericList(4))->begin
  local x:=reconstructPoints(alpha,phi);
  local d:=x.agg(+)/x.size;
  x:=x.map((p)->p-d);
  plot3DPoly(x/x.euklideanNorm.max);
end;

animateHeptagon(alpha:Numeric,coeff:Map)->begin
  local points:=
  sampleCurve(coeff[KEY_KOEFF],coeff[KEY_PHASE],[0..199]/200*2*pi).pMap((phi)->reconstructPoints(alpha,phi));
  local d:=points.agg(|).{$L.agg(+)/$L.size};
  points:=points.map((x)->x.map((p)->p-d));
  points:=points/(points.agg(|).euklideanNorm.max);
  points.each(p,begin
    plot3DPoly(p);
    addAnimationFrame;
  end);
end;

makeWalk(allCoefficients:Map,startSubIdx:Int,startAngle:Numeric)->begin
  local configs:=[].toMap;
  local c:=allCoefficients[4500,startSubIdx];
  local lastConfig :=sampleCurve(c[KEY_KOEFF],c[KEY_PHASE],[startAngle])[0];
  local lastManifestation:=reconstructPoints(4.5*pi/7,lastConfig);

  configs[4500]:=[lastConfig,lastManifestation];


  local remainingAngles:=allCoefficients.getInner(0).filter((i)->4500<i<4666.666).sort;
  local distToLast:=(phi)->euklideanNorm(lastConfig-phi);
  local expandByRemainingAngles:={
  while(remainingAngles.size>0,begin
    local nextAngle:=remainingAngles.head; remainingAngles:=remainingAngles.tail;
    log('k=',nextAngle);

    local candidates:=allCoefficients[nextAngle];
    local nextPhi:=candidates.pEach(candidate,findPointOnCurveMinimizing(candidate[KEY_KOEFF].head(30),candidate[KEY_PHASE],distToLast))
    .min[2];

    lastManifestation:=reconstructPoints(nextAngle*pi/7000,nextPhi);
    configs[nextAngle]:=[lastConfig:=nextPhi,lastManifestation];
  end)};
  expandByRemainingAngles();

  remainingAngles:=allCoefficients.getInner(0).filter((i)->4666.666<i).min.toList;
  distToLast:=(phi)->(reconstructPoints(4.667*pi/7,phi)-lastManifestation).flatten.euklideanNorm;
  expandByRemainingAngles();

  remainingAngles:=allCoefficients.getInner(0).filter((i)->i>configs.getInner(0).max).sort;
  distToLast:=(phi)->euklideanNorm(lastConfig-phi);
  expandByRemainingAngles();

  lastConfig:=configs[4500,0];
  lastManifestation:=configs[4500,1];
  remainingAngles:=allCoefficients.getInner(0).filter((i)->4000<=i<4500).sort.reverseList;
  expandByRemainingAngles();
  lastConfig;
  lastConfig.euklideanNorm>1E-3
  ? begin
      remainingAngles:=allCoefficients.getInner(0).filter((i)->i<4000).sort.reverseList;
      expandByRemainingAngles();
    end
  : void;

  //reduce configs to equidistant steps:

  local points:=configs.sort.map({$cfg[0] mod 5 = 0 ? $cfg[1,1] : void});
  local d:=points.agg(|).{$L.agg(+)/$L.size};
  points:=points.map((x)->x.map((p)->p-d));
  points:=points/(points.agg(|).euklideanNorm.max);
  points.each(p,begin
    plot3DPoly(p);
    addAnimationFrame;
  end);

end;

