USE fourierCurves;

@SuppressUnusedParameterWarning
type Matrix(L:NumericList(9))->true;
OPERATOR_MULT(x:Matrix,y:Matrix)->
  [x[0]*y[0]+x[1]*y[3]+x[2]*y[6],
   x[0]*y[1]+x[1]*y[4]+x[2]*y[7],
   x[0]*y[2]+x[1]*y[5]+x[2]*y[8],
   x[3]*y[0]+x[4]*y[3]+x[5]*y[6],
   x[3]*y[1]+x[4]*y[4]+x[5]*y[7],
   x[3]*y[2]+x[4]*y[5]+x[5]*y[8],
   x[6]*y[0]+x[7]*y[3]+x[8]*y[6],
   x[6]*y[1]+x[7]*y[4]+x[8]*y[7],
   x[6]*y[2]+x[7]*y[5]+x[8]*y[8]].toMatrix;
private rx(alpha:Numeric)->
   [1, 0         , 0         ,
    0, cos(alpha),-sin(alpha),
    0, sin(alpha), cos(alpha)].toMatrix;
private rz(alpha:Numeric)->
  [cos(alpha),-sin(alpha), 0,
   sin(alpha), cos(alpha), 0,
   0,          0,          1].toMatrix;

private reconstructPoints(alpha:Numeric,phi:NumericList(4),x0:NumericList(3),initialMatrix:Matrix)->begin
  local a:=initialMatrix;
  local d:=[a[[0,3,6]]];
  local rotZ:=rz(alpha);
  a*=           rotZ; d ||=a[[0,3,6]];
  a*=rx(phi[0])*rotZ; d ||=a[[0,3,6]];
  a*=rx(phi[1])*rotZ; d ||=a[[0,3,6]];
  a*=rx(phi[2])*rotZ; d ||=a[[0,3,6]];
  a*=rx(phi[3])*rotZ; d ||=a[[0,3,6]];
  local x:=x0;
  x:=[x0]|d.each(edge,x+=edge);
  x;
end;
private reconstructPoints(alpha:Numeric,phi:NumericList(4))->reconstructPoints(alpha,phi,[0,0,0],[1,0,0,0,1,0,0,0,1].toMatrix);

//private plot3DPoly(points:List)->begin
//  local t:=points|points.head(2);
//  local points:=
//  [t.leading(2),t.leading.tail,t.tail(2)].transpose.pEach(triplet,begin
//    local x0:=triplet[0];
//    local x1:=triplet[1];
//    local x2:=triplet[2];
//    local a:=(x0-x1);  a/=a.euklideanNorm;
//    local b:=(x2-x1);
//    local alpha:=arccos((b*a).agg(+)/b.euklideanNorm);
//    b-=(b*a).agg(+)*a;
//    b/=b.euklideanNorm;
//
//    ([0..299]/300).each(w,x0*(1-w)+x1*w)|
//    ([0..50]/50*alpha).each(phi,x1+b*0.1*sin(phi)+a*0.1*cos(phi));
//  end,|);
//
//  local perspectivity:=0.5;
//  local xy:=points.map(::leading);
//  local z:=points.getInner(2);
//  local factor:=1/(z-1*(1/perspectivity+1))/perspectivity*0.95*(1+perspectivity);
//  xy*=factor;
//  z:=round((z+1)/2*STYLES.size).map((q)->min(200,max(0,q)));
//
//  setOptions(["x0"=>-1,"x1"=>1,"y0"=>-1,"y1"=>1,"autoscaleX"=>false,"autoscaleY"=>false,"axisStyleX"=>0,"axisStyleY"=>0].toMap);
//  plot();
//  group(xy,z).sort.each(g,addPlot(g[1],STYLES[200-g[0]]));
//end;

private plot3DPoly(points:List)->begin
  local perspectivity:=0.5;
  local xy:=points.map(::leading);
  local z :=points.getInner(2);
  local factor:=1/(z-1*(1/perspectivity+1))/perspectivity*0.95*(1+perspectivity);
  setOptions(["x0"=>-1,"x1"=>1,"y0"=>-1,"y1"=>1,"autoscaleX"=>false,"autoscaleY"=>false,"axisStyleX"=>0,"axisStyleY"=>0].toMap);
  plot();

  xy*=factor;

  local toPlot:=
  [0..6].map((i)->begin
           local j:=(i+1) mod 7;
           local delta:=xy[j]-xy[i];
           delta/=delta.euklideanNorm;
           delta:=[-delta[1],delta[0]]*0.01;
           [(z[i]+z[j])/2,
            [xy[i]-factor[i]*delta,
             xy[j]-factor[j]*delta,
             xy[j]+factor[j]*delta,
             xy[i]+factor[i]*delta],
            [xy[i]-factor[i]*0.015,
             xy[i]+factor[i]*0.015,
             xy[j]-factor[j]*0.015,
             xy[j]+factor[j]*0.015]];
         end).sort;
  toPlot.each(edge,
    addPlot(edge[1],'GREY0.8 polygon fs'),
    addPlot(edge[1],'black'),
    addPlot(edge[2],'GREY0.8 ellipse fs'),
    addPlot(edge[2],'ellipse black'));
end;

animateHeptagon(alpha:Numeric,coeff:Map)->begin
  local realPeriod:=-coeff[KEY_PHASE]*2*pi/7;

  local points:=void;
  local pointCount:=100;
  local makePoints:={begin
    local curveTime:=[0..pointCount-1]*realPeriod/pointCount;
    [sampleCurve(coeff[KEY_KOEFF],coeff[KEY_PHASE],curveTime),curveTime/realPeriod]
    .transpose
    .map((phi_T)->reconstructPoints(alpha,phi_T[0],[1,0,0]*phi_T[1],rz(alpha*phi_T[1])));
  end};
  points:=makePoints();
  pointCount:=ceil((points.tail-points.leading).map((d)->d.euklideanNorm.max).max*1300).max(1);
  points:=makePoints();

  local d:=points.agg(|).{$L.agg(+)/$L.size};
  points:=points.map((x)->x.map((p)->p-d));
  points:=points/(points.agg(|).euklideanNorm.max);
  points.each(p,begin
    plot3DPoly(p);
    addAnimationFrame;
  end);
end;

makeWalk(allCoefficients:Map,startSubIdx:Int,startAngle:Numeric)->begin
  local configs:=[].toMap;
  local lastConfig :=begin
    local c:=allCoefficients[4500,startSubIdx];
    sampleCurve(c[KEY_KOEFF],c[KEY_PHASE],[startAngle])[0];
  end;
  local lastManifestation:=reconstructPoints(4.5*pi/7,lastConfig);

  configs[4500]:=[lastConfig,lastManifestation];
  local remainingAngles:=allCoefficients.getInner(0).filter((i)->4500<i<4666.666).sort;
  local distToLast:=(phi)->euklideanNorm(lastConfig-phi);
  local expandByRemainingAngles:={begin
    local validPhases:=[1..3];
    while(remainingAngles.size>0,begin
      local nextAngle:=remainingAngles.head; remainingAngles:=remainingAngles.tail;
      log('k=',nextAngle);

      local candidates:=allCoefficients[nextAngle].filter((coeff)->coeff[KEY_PHASE] in validPhases);
      local nextPhi:=candidates.pEach(candidate,[findPointOnCurveMinimizing(candidate[KEY_KOEFF].head(30),candidate[KEY_PHASE],distToLast),candidate[KEY_PHASE]]).min;
      validPhases:=[nextPhi[1]];
      nextPhi:=nextPhi[0,2];

      lastManifestation:=reconstructPoints(nextAngle*pi/7000,nextPhi);
      configs[nextAngle]:=[lastConfig:=nextPhi,lastManifestation];
    end);
  end};
  expandByRemainingAngles();

  remainingAngles:=allCoefficients.getInner(0).filter((i)->4666.666<i).min.toList;
  distToLast:=(phi)->(reconstructPoints(4.667*pi/7,phi)-lastManifestation).flatten.euklideanNorm;
  expandByRemainingAngles();

  remainingAngles:=allCoefficients.getInner(0).filter((i)->i>configs.getInner(0).max).sort;
  distToLast:=(phi)->euklideanNorm(lastConfig-phi);
  expandByRemainingAngles();

  lastConfig:=configs[4500,0];
  lastManifestation:=configs[4500,1];
  remainingAngles:=allCoefficients.getInner(0).filter((i)->4000<=i<4500).sort.reverseList;
  expandByRemainingAngles();
  lastConfig;
  lastConfig.euklideanNorm>1E-3
  ? begin
      remainingAngles:=allCoefficients.getInner(0).filter((i)->i<4000).sort.reverseList;
      expandByRemainingAngles();
    end
  : void;

  //reduce configs to equidistant steps:
  configs:=configs.sort.filter({$cfg[0] mod 5 = 0});
  local points:=configs.map({$cfg[1,1]});
  local d:=points.agg(|).{$L.agg(+)/$L.size};
  points:=points.map((x)->x.map((p)->p-d));
  points:=points/(points.agg(|).euklideanNorm.max);
  points.each(p,begin
    plot3DPoly(p);
    drawTextAbsolute(0.01,0.99,format('α=%{$0/1000}5.3fπ/7=%{$0*0.02571428571428571}4.1f°',configs[index,0]),'TL');
    addAnimationFrame;
  end);
end;

animateHeptagon(pi/2,
  ['coefficients'=>[1.7603381853024849,-0.029886508418467888,0.08952667725915056,-0.025930050300320587,-0.0030753602728763344,-0.0006910307417538619,-0.00019640981999281145,0.000033527020197751369,0.00001234376371397253,-0.000020356172617316735,9.850141106805E-6],
   'phaseShift'  =>2].toMap);

