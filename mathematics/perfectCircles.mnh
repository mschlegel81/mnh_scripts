private center(aPhi,k)->aPhi[0]^k*[cos(aPhi[1]*k),sin(aPhi[1]*k)];
private rad0(aPhi)->euklideanNorm(center(aPhi,1)-[1,0])/(1+aPhi[0]);
private errorFunc(k)->
 {begin
    sqr(euklideanNorm(center($aPhi,k  )-[1,0])-((local r0:=rad0($aPhi))+r0*$aPhi[0]^k    ))
   +sqr(euklideanNorm(center($aPhi,k+1)-[1,0])-(       r0              +r0*$aPhi[0]^(k+1)));
  end};

USE downhillSimplex;
private datastore CONFIG_OF_K:=[[2,downhillSimplex(errorFunc(2),[2.89,2.23],0.001,1E-15)[1]]].toMap;
findSolution(forK>=2)->CONFIG_OF_K[forK] orElse begin
  local maxK:=CONFIG_OF_K.getInner(0).max;
  local par:=CONFIG_OF_K[maxK];
  [maxK+1..forK].each(k,begin
    (k-[9..1]/10).each(subK,par:=downhillSimplex(errorFunc(subK),par,0.001,1E-10,DEFAULT_DOWNHILL_SIMPLEX_OPTIONS.withStepLimit(10))[1]);
                            par:=downhillSimplex(errorFunc(k   ),par,0.001,1E-15)[1];
    note('New solution computed for k=',k,'; ',par);
    CONFIG_OF_K[k]:=par;
    void;
  end);
  CONFIG_OF_K[forK];
end;

plotCircles(k)->plotCircles(k,1,0);
plotCircles(k,zoom,rotate)->begin
  setOptions([['x0',-1],['x1',1],['autoscaleX',false],['axisStyleX',0],['logscaleX',false],
              ['y0',-1],['y1',1],['autoscaleY',false],['axisStyleY',0],['logscaleY',false],
              ['preserveAspect',true]]);
  local par:=findSolution(k);
  par[0]<1 ? par[0]:=1/par[0] : void;
  local I:=[floor(ln(1E-2/zoom)/ln(par[0]))..
            ceil (ln(2        )/ln(par[0]))];

  local scale  :=par[0]^I*zoom;
  local radii  :=rad0(par)*scale;
  local centers:=[scale*cos(par[1]*I-rotate),
                  scale*sin(par[1]*I-rotate)].transpose;
  plot();
  I.group(((I mod k)+k) mod k)
   .sort
   .getInner(1)
   .each(J,begin
      local style:='ellipse fs 0 HUE'&(index/k);
      (J-I[0]).each(j,centers[j]-radii[j],
                      centers[j]+radii[j]).addPlot(style);
    end);
 // centers.each(center,center-radii[index],center+radii[index]).addPlot('ellipse black');
end;

//*Creates and displays an animation
main('animate')->begin
  clearAnimation;
  [2..max(50,CONFIG_OF_K.getInner(0).max)]
    .each(k,plotCircles(k),
            addAnimationFrame,
            index=0 ? display : void);
  display;
end;

@demo_for=animation, datastores, math, numerics/optimization
main(anim in ['zoomin','zoomout'],K)->
begin
  local k:=K.toInt;
  clearAnimation;
  local z:=      findSolution(k)[0]^((2*k) /50);
  local p:=(pi*4-findSolution(k)[1]* (2*k))/50;
  (anim=='zoomin' ? [0..49] : [49..0])
  .each(i,plotCircles(k,z^i,p*i),
                 addAnimationFrame,
                 index=0 ? display : void);
end;


