private randomOf(collection:Collection)->collection.toList[intRandom(collection.size)];
private CROSS_D1:=[[-1,0],[1,0],[0,-1],[0,1]].toSet;
private CROSS_D2:=[[-2,0],[2,0],[0,-2],[0,2]].toSet;
//private findStitchPoint(runA:Set,runB:Set,allowedStitchPoints:Set)->
//  intersect(runA+CROSS_D1,
//            runB+CROSS_D1,
//            allowedStitchPoints).randomOf;

makeMaze(width,height)->makeMaze(width,height,[]);
makeMaze(width,height,mask:BooleanList)->begin
  local toBeVisited:=cross([0..ceil(height/2)-1]*2,
                           [0..ceil(width /2)-1]*2);
  toBeVisited:=
    mask.size=0
    ? toBeVisited.toSet
    : toBeVisited.intersect(indexOf(mask).divMod(width));

  local allowedMidPoints:=cross([0..ceil(height/2)-1]*2+1,[0..ceil(width/2)-1]*2  ).union(
                          cross([0..ceil(height/2)-1]*2  ,[0..ceil(width/2)-1]*2+1));
  allowedMidPoints:=
    mask.size=0
    ? allowedMidPoints.toSet
    : allowedMidPoints.intersect(indexOf(mask).divMod(width));

  local runs:=[];
  begin
    local p:=
    local next:=
    local currentRun:=void;
    local walk:={
      while(next.size>0,begin
        next:=randomOf(next);
        local midPoint:=(p+next).shiftRight(1);
        midPoint in allowedMidPoints
        ? begin
            currentRun|=[midPoint,p:=next];
            toBeVisited>>p;
            next:=intersect([p].toSet+CROSS_D2,toBeVisited);
          end
        : next:=[];
      end)};

    while(toBeVisited.size>0,begin
      local runSeed:=
      p:=randomOf(toBeVisited);
      currentRun:=[p];
      toBeVisited>>p;

      next:=intersect([p].toSet+CROSS_D2,toBeVisited);
      walk();

      currentRun:=currentRun.reverseList;
      p:=runSeed;
      next:=intersect([p].toSet+CROSS_D2,toBeVisited);
      walk();
      runs||=currentRun;
    end);
  end;
  toBeVisited:=void;

  local merges:=runs.size<2 ? [] : begin
    allowedMidPoints:=allowedMidPoints.minus(runs.agg(|));
    log('Potential merges: ',(runs.size*(runs.size-1))/2,' along ',allowedMidPoints.size,' stitch points');
    local runSurrounds:=runs.pMap((run)->(run.toSet+CROSS_D1).intersect(allowedMidPoints));
    allowedMidPoints:=void;
    [runs.size-1..1].pEach(idx0,begin
      local run0s:=runSurrounds  [idx0];
      [0..idx0-1].each(idx1,
        begin
          local stitchPointCandidates:=intersect(run0s,runSurrounds[idx1]);
          stitchPointCandidates.size=0
          ? void
          : [idx0,idx1,randomOf(stitchPointCandidates)];
        end);
    end,|);
  end;
  allowedMidPoints:=void;


  log('Naive     merges: ',merges.size);
  merges.size>0 ? merges:=merges[merges.size.random.sortPerm] : void;

  local mazePoints:=[];
  while(merges.size>0,begin
    local connected:=[merges[0,0]].toSet;
    local mergeSizeBefore:=0;
    while(merges.size!=mergeSizeBefore,begin
      mergeSizeBefore:=merges.size;
      note(mergeSizeBefore);
      merges:=
      merges.each(m,
        m[0] in connected xor m[1] in connected
        ? begin
            local idx0:=m[0];
            local idx1:=m[1];
            mazePoints||=m[2];
            connected|=idx0;
            connected|=idx1;
          end
        : m[0] in connected AND m[1] in connected ? void : m);
    end);
  end);
  mazePoints:=runs.agg(|).union(mazePoints);
  cross([0..height-1],[0..width-1]).pMap((p)->p in mazePoints);
end;

shrinkMaze(maze:List,width>1)->begin
  local nonzeroEntries:=indexOf(maze).pMap((i)->i.divMod(width)).toSet;
  local N:=cross([-1..1],[-1..1]).toSet;
  [0..maze.size-1].divMod(width).pMap((q)->isSubsetOf([q].toSet+N,nonzeroEntries));
end;

growMaze(maze:List,width>1)->begin
  local zeroEntries:=indexOf(!maze).pMap((i)->i.divMod(width)).toSet;
  zeroEntries:=zeroEntries.union(begin
    local height:=maze.size div width;
     map([-1..  width],{[-1    ,$i   ]})|
     map([-1.. height],{[$j    ,width]})|
     map([width..  -1],{[height,$i   ]})|
     map([height.. -1],{[$j    ,-1   ]});
  end);
  local N:=cross([-1..1],[-1..1]).toSet;
  [0..maze.size-1].divMod(width).pMap((q)->!isSubsetOf([q].toSet+N,zeroEntries));
end;

halfGrowMaze(maze:List,width>1)->begin
  local zeroEntries:=indexOf(!maze).pMap((i)->i.divMod(width)).toSet;
  zeroEntries:=zeroEntries.union(begin
    local height:=maze.size div width;
     map([-1..  width],{[-1    ,$i   ]})|
     map([-1.. height],{[$j    ,width]})|
     map([width..  -1],{[height,$i   ]})|
     map([height.. -1],{[$j    ,-1   ]});
  end);
  local N:=cross([0..1],[0..1]).toSet;
  [0..maze.size-1].divMod(width).pMap((q)->!isSubsetOf([q].toSet+N,zeroEntries));
end;

scaleMaze(maze:List,width>1,scalingFactor>1)->begin
  local height:=maze.size div width;
  local C:=
  cross([0..height*scalingFactor-1] div scalingFactor,
        [0..width *scalingFactor-1] div scalingFactor);
  maze[(C.transpose*[width,1]).agg(+)];
end;

shiftMazeUpRight(maze:List,width>1)->begin
  local height:=maze.size div width;
  local C:=
  cross([0,0..height-1],
        [0,0..width -1]);
  maze[(C.transpose*[width,1]).agg(+)];
end;

cropMaze(maze:List,currentWidth,newWidth<=currentWidth,newHeight)->begin
  local C:=cross([0..newHeight-1],
                 [0.. newWidth-1]);
  maze[(C.transpose*[currentWidth,1]).agg(+)];
end;

plotMaze(maze:BooleanList,width)->begin
  maze.map((m)->m?0:0.9).plotRasterImage(width);
  setOptions(["x0"=>-1,"x1"=>1,"y0"=>-1,"y1"=>1,"fontsize"=>8.264462809917354,"preserveAspect"=>true,"autoscaleX"=>true,"autoscaleY"=>true,"logscaleX"=>false,"logscaleY"=>false,"autoscaleFactor"=>1,"axisStyleX"=>1,"axisStyleY"=>1].toMap);
  addAnimationFrame;
end;

private makeFractalMaze_(width,height)->
  width<=20 OR height<=20
  ? [makeMaze(width-ord((width and 1)=0),height-ord((height and 1)=0)),
             [width-ord((width and 1)=0),height-ord((height and 1)=0)]]
  : begin
      local r:=([width,height]-1) div 4;
      r-=ord((r and 1)=0);
      local
      M:=  makeFractalMaze_(r[0],r[1]);
      r:=M[1];
      M:=M[0].scaleMaze(r[0],4); r*=4;
      M:=M.halfGrowMaze(r[0]).shiftMazeUpRight(r[0]); r+=1;
      [makeMaze(r[0],r[1],M),r];
    end;

makeFractalMaze(width,height)->begin
  local m:=makeFractalMaze_(width,height);
  local currentResolution:=m[1];
  local centerDiff:=[height-currentResolution[1],
                     width -currentResolution[0]] div 2;
  cross([0..height-1]-centerDiff[0],
        [0..width-1 ]-centerDiff[1]).pMap((K)->
    0<=K[0]<currentResolution[1] AND
    0<=K[1]<currentResolution[0] ?
    m[0,K[0]*currentResolution[0]+K[1]] : false);
end;


//makeFractalMaze(16*24,9*24).plotMaze(16*24);

//
//2: LONG RANGE:
//begin
//  local res:=[5,5];
//  local M:=makeMaze(res[0],res[1],[]);
//  M.plotMaze(res[0]);
//
//  M:=M.scaleMaze(res[0],3); res*=3;
//  M:=M.growMaze(res[0]).shiftMazeUpRight(res[0]); res+=1;
//  M:=M.reverseList.shiftMazeUpRight(res[0]).reverseList; res+=1;
//  M.plotMaze(res[0]);
//  M:=makeMaze(res[0],res[1],M);
//  M.plotMaze(res[0]);
//
//  M:=M.scaleMaze(res[0],3); res*=3;
//  M:=M.growMaze(res[0]).shiftMazeUpRight(res[0]); res+=1;
//  M:=M.reverseList.shiftMazeUpRight(res[0]).reverseList; res+=1;
//  M.plotMaze(res[0]);
//  M:=makeMaze(res[0],res[1],M);
//
//  M:=M.reverseList.shiftMazeUpRight(res[0]).reverseList; res+=1;
//  M.plotMaze(res[0]);
//  log(res);
//  M.ord;
//end;

//longRangeMaze->begin
//  local res:=[5,5];
//  local M:=makeMaze(res[0],res[1],[]);
//  M:=M.scaleMaze(res[0],3); res*=3;
//  M:=M.growMaze(res[0]).shiftMazeUpRight(res[0]); res+=1;
//  M:=M.reverseList.shiftMazeUpRight(res[0]).reverseList; res+=1;
//  M:=makeMaze(res[0],res[1],M);
//  M:=M.scaleMaze(res[0],3); res*=3;
//  M:=M.growMaze(res[0]).shiftMazeUpRight(res[0]); res+=1;
//  M:=M.reverseList.shiftMazeUpRight(res[0]).reverseList; res+=1;
//  M:=makeMaze(res[0],res[1],M);
////  M:=M.reverseList.shiftMazeUpRight(res[0]).reverseList; res+=1;
//  M;
//end;


//hueOf(h<1.0)->[1,h,0];
//hueOf(h<2.0)->[1-(h-1),1,0];
//hueOf(h<3.0)->[0,1,h-2];
//hueOf(h<4.0)->[0,1-(h-3),1];
//hueOf(h<5.0)->[h-4,0,1];
//hueOf(h  )->[1,0,1-(h-5)];
//HUE(h)->hueOf((h-floor(h))*6);
//
//colorMaze(maze:BooleanList,width:Int)->begin
//  local mazePoints:=maze.indexOf.divMod(width);
//  local c:=[(maze.size div width)/2,width/2]*0;
//  local seedPoint:=mazePoints.pEach(p,euklideanNorm(p-c)=>p,min)[1];
//
//  local v:=[seedPoint=>0].toMap;
//  mazePoints:=mazePoints.minus(v.getInner(0));
//
//  while(mazePoints.size>0,begin
//    mazePoints:=mazePoints.each(p,begin
//      local X:=v.getAll(CROSS_D1.each(d,d+p)).min;
//      X.isInt
//      ? begin
//          v[p]:=X+1;
//          void;
//        end
//      : p;
//    end);
//  end);
//  begin
//    local D:=v.getInner(1).sort;
//    note('DIST: ',D[D.size div 2],' / ',D.trailing);
//  end;//
//  v:=v.pEach(e,e[0]=>HUE(e[1]/200)).toMap;
//
//
//  [0..maze.size-1].divMod(width).pEach(c,v[c] orElse 0).plotRasterImage(width);
//
//end;
//
//begin
//  makeMaze(53,53).colorMaze(53);  addAnimationFrame;
//  makeMaze(53,53).colorMaze(53);  addAnimationFrame;
//  makeMaze(53,53).colorMaze(53);  addAnimationFrame;
//  makeMaze(53,53).colorMaze(53);  addAnimationFrame;
//  makeMaze(53,53).colorMaze(53);  addAnimationFrame;
//  longRangeMaze.colorMaze(53);    addAnimationFrame;
//  longRangeMaze.colorMaze(53);    addAnimationFrame;
//  longRangeMaze.colorMaze(53);    addAnimationFrame;
//  longRangeMaze.colorMaze(53);    addAnimationFrame;
//  longRangeMaze.colorMaze(53);    addAnimationFrame;
//end;

////1: FRACTAL MAZE zoomin!!
begin
  local res:=[5,
              5];
  local M:=makeMaze(res[0],res[1]);
  local center:=res/2;
  local SCALE_THRESHOLD:=0.004;
  local scale:=SCALE_THRESHOLD;

  local BOXES:=indexOf(M).divMod(res[0]).each(b,b-center,b-center+1);
  local COARSER_BOXES:=[[0,0],[1,1]];

  [0..1000].each(zoomStep,begin
    scale*=4^(1/50);
    log(index,'/',ln(SCALE_THRESHOLD/scale)/ln(4));

    scale>SCALE_THRESHOLD ? begin
      local cropBound:=floor(center.reverseList-1-[9/16,1]/scale);


      cropBound-=ord((cropBound and 1)=1);
      log('cropBound= ',cropBound);
      (cropBound>0).agg(or)
      ? begin
          cropBound:=cropBound*ord(cropBound>0);
          local startOfCropping:=scriptTime;
          warn('Cropping @',res,' by ',cropBound);
          local halfCrop:=res-cropBound;
          local fullCrop:=res-cropBound*2;

          M:=M.cropMaze(res[0],halfCrop[0],halfCrop[1])
              .reverseList
              .cropMaze(halfCrop[0],fullCrop[0],fullCrop[1])
              .reverseList;
          log('Time for cropping: ',scriptTime-startOfCropping);
          res:=fullCrop;
          center:=res.reverseList/2;
          //Will be carried on in COARSER_BOXES
          BOXES:=indexOf(M).divMod(res[0]).each(b,b-center,b-center+1);
        end
      : void;

      M:=M.scaleMaze(res[0],4); res*=4; scale/=4;
      M:=M.halfGrowMaze(res[0]).shiftMazeUpRight(res[0]); res+=1;
      center:=res.reverseList/2;
      M:=makeMaze(res[0],res[1],M);
      COARSER_BOXES:=BOXES;
      BOXES:=indexOf(M).divMod(res[0]).each(b,b-center,b-center+1);
      callMemoryCleaner;
    end : void;

    ['autoscaleFactor'=>1,
     'autoscaleX'=>false,
     'autoscaleY'=>false,
     'axisStyleX'=>0,
     'axisStyleY'=>0,
     'fontsize'=>10,
     'logscaleX'=>false,
     'logscaleY'=>false,
     'preserveAspect'=>true,
     'x0'=>-1,
     'x1'=> 1,
     'y0'=>-9/16,
     'y1'=> 9/16].toMap.setOptions;

    local fineAlpha  :=max(0,min(1,1-ln(SCALE_THRESHOLD/scale)/ln(4)));
    local coarseAlpha:=max(0,min(1,  2*ln(SCALE_THRESHOLD/scale)/ln(4)));
    plot();
    fineAlpha  >0 ? addPlot(BOXES           *scale ,'box 0 fs RGB0,0,0,'&fineAlpha  ) : void;
    coarseAlpha>0 ? addPlot(COARSER_BOXES*(4*scale),'box 0 fs RGB0,0,0,'&coarseAlpha) : void;
//    addPlot([-[1,9/16],[1,9/16]],'red box');

    addAnimationFrame;
  end);
end;
