#!C:\bin\mnh.exe -v1 -quiet -headless -convertPrintToLog -logDateFmt hh:mm:ss.zzz -logLocationLength 10 +log stdOut(10)
plain script;

PLOT_TO_FILE:=true;
sysWidth :=16*20;
sysHeight:= 9*20;
exportResolution:=[sysWidth,sysHeight]; //[1920,1080]

//PLOT_TO_FILE:=false;
//sysWidth :=50;
//sysHeight:=50;
//exportResolution:=[sysWidth,sysHeight]; //[1920,1080]

BRANCH_THRESHOLD:=1;
EAT_PER_ROUND:=0.1;
DIE_THRESHOLD:=EAT_PER_ROUND;
TAXIS_STEP:=0.45;

mutable food:=map([0..sysWidth*sysHeight-1],(k)->[k mod sysWidth,k div sysWidth]-([sysWidth,sysHeight]-1)/2)
              ./(min(sysWidth,sysHeight))
              .euklideanNorm
              .map((x)->x>1 ? 0 : (1-x)Â²)*(BRANCH_THRESHOLD+2*EAT_PER_ROUND);

//EAT_PER_ROUND+EAT_PER_ROUND*random(sysWidth*sysHeight);
mutable foodGradient:=void;
limitIndex(i,j)->max(0,min(sysWidth-1,i))+max(0,min(sysHeight-1,j))*sysWidth;

di00:=[0..sysWidth*sysHeight-1].pMap((k)->[k mod sysWidth,k div sysWidth]+[-1,-1]).map((k)->limitIndex@k);
di10:=[0..sysWidth*sysHeight-1].pMap((k)->[k mod sysWidth,k div sysWidth]+[ 0,-1]).map((k)->limitIndex@k);
di20:=[0..sysWidth*sysHeight-1].pMap((k)->[k mod sysWidth,k div sysWidth]+[ 1,-1]).map((k)->limitIndex@k);
di01:=[0..sysWidth*sysHeight-1].pMap((k)->[k mod sysWidth,k div sysWidth]+[-1, 0]).map((k)->limitIndex@k);
di21:=[0..sysWidth*sysHeight-1].pMap((k)->[k mod sysWidth,k div sysWidth]+[ 1, 0]).map((k)->limitIndex@k);
di02:=[0..sysWidth*sysHeight-1].pMap((k)->[k mod sysWidth,k div sysWidth]+[-1, 1]).map((k)->limitIndex@k);
di12:=[0..sysWidth*sysHeight-1].pMap((k)->[k mod sysWidth,k div sysWidth]+[ 0, 1]).map((k)->limitIndex@k);
di22:=[0..sysWidth*sysHeight-1].pMap((k)->[k mod sysWidth,k div sysWidth]+[ 1, 1]).map((k)->limitIndex@k);

randomOnUnitSphere->begin
  local r:=random(2);
  while(!(0.01<=r.euklideanNorm<1),r:=random(2));
  r/r.euklideanNorm;
end;

updateFoodGradient->begin
  local bounds:=[[0..sysWidth*sysHeight-1].map((k)->k mod sysWidth).map((ix)->ix=0 ? 1 : ix=sysWidth -1 ? -1 : 0),
                 [0..sysWidth*sysHeight-1].map((k)->k div sysWidth).map((iy)->iy=0 ? 1 : iy=sysHeight-1 ? -1 : 0)];
save;
  foodGradient:=
 ([(food[di20]-food[di00])+2*(food[di21]-food[di01])+(food[di22]-food[di02]),
   (food[di02]-food[di00])+2*(food[di12]-food[di10])+(food[di22]-food[di20])]
  +bounds)
  .transpose;
end;

diffuseFood->begin
  food+=(food[di10]+food[di12]+
         food[di01]+food[di21]-4*food)*0.05;
  void;
end;

foodAt(ix in [0..sysWidth-1],iy in [0..sysWidth-1])->food[ix+iy*sysWidth];
foodAt(x:Int,y:Int)->0;
foodAt(x:Real,y:Real)->foodAt(round(x),round(y));


foodGradientAt(x<1            ,y)->[ 1,0];
foodGradientAt(x>(sysWidth-2) ,y)->[-1,0];
foodGradientAt(x,y<1            )->[0, 1];
foodGradientAt(x,y>(sysHeight-2))->[0,-1];
foodGradientAt(x,y)->begin
  local wx:=x-(local ix:=floor(x));
  local wy:=y-(local iy:=floor(y));
  local g:=
  (foodGradient[limitIndex(ix  ,iy  )]*(1-wx)
  +foodGradient[limitIndex(ix+1,iy  )]*   wx )*(1-wy)+
  (foodGradient[limitIndex(ix  ,iy+1)]*(1-wx)
  +foodGradient[limitIndex(ix+1,iy+1)]*   wx )*   wy;
  g/=g.euklideanNorm;
  g.isNan.agg(or) ? randomOnUnitSphere : g;
end;


//consumeFoodAt(x:Numeric,y:Numeric)->food[min(sysWidth -1,max(0,x.round))+
//                                         min(sysHeight-1,max(0,y.round))*sysWidth]-=EAT_PER_ROUND;
consumeFoodAt(x:Numeric,y:Numeric)->begin
  local ix:=x.round;
  local iy:=y.round;
  0<=ix<sysWidth AND 0<=iy<sysHeight
  ? food[x.round+y.round*sysWidth]-=EAT_PER_ROUND
  : void;
end;

plotSystem(points)->begin
  local STYLE:=[0..200].map((i)->'box fs 0 HSV0.6,'&max(0,2-i/100)&','&min(1,i/100));
  local WHITE_LEVEL:=max(BRANCH_THRESHOLD,EAT_PER_ROUND*5) *1.5;
  local foodCoordinates:=[0..sysWidth*sysHeight-1]
     .map((k)->[k mod sysWidth,k div sysWidth])
     .map((p)->[p,p+1]);
save;
  setOptions(["axisStyleX"=>0,"axisStyleY"=>0,
              "x0"=>0,"x1"=>sysWidth,
              "y0"=>0,"y1"=>sysHeight,
              "autoscaleX"=>false,
              "autoscaleY"=>false].toMap);
  plot();
  group(foodCoordinates,food.pMap((f)->f.max(0).min(WHITE_LEVEL).*((STYLE.size-1)/WHITE_LEVEL).round))
  .pMap((g)->addPlot(g[1].agg(|),STYLE[g[0]] orElse fail));
//  points.size=0 ? void : addPlot(points,'orange . 0.5');
end;

plotToNextFile->begin
  local i:=0;
save;
  local filename:=void;
  while(fileExists(filename:=myPath.changeFileExt(format('_%4.4d.png',i))),i+=1);
  note('Rendering to ',filename);
  renderToFile(filename,exportResolution[0],exportResolution[1],true);
end;

begin
  local points:=[[0.5*sysWidth,0.5*sysHeight]];
  updateFoodGradient;
  [1..6000].each(step,begin
    local tide:=[sin(step*pi/500),
                 cos(step*pi/500)];
    local foodDelta:=([0..sysWidth*sysHeight-1]
      .pMap((k)->(([k mod sysWidth,k div sysWidth]-([sysWidth,sysHeight]-1)/2)*tide).agg(+)).>=(0).ord)*(1E-3*1.001^step);
//    local foodDelta:=((([0..sysWidth*sysHeight-1] mod sysWidth)/(sysWidth-1)*2-1)*cos(step*pi/500)+1)*0.01;

    food+=foodDelta;
    points.each(p,consumeFoodAt@p);
    food:=food.map((f)->max(0,f));
    local multiply:=-points.size;
    local tips:=
    points.pEach(tip,begin
      local g:=TAXIS_STEP*foodGradientAt@tip;
      foodAt@tip>BRANCH_THRESHOLD
      ? [tip+(g-[-g[1],g[0]])*sqrt(0.5),
         tip+(g+[-g[1],g[0]])*sqrt(0.5)]
      : [tip+g];
    end,|);
    multiply+=tips.size;
    points:=tips.filter((p)->(foodAt@p).orElse(-10)>DIE_THRESHOLD);
    points.size=0 ? points:=tips[[0]] : void;
    local dieOff  :=tips.size-points.size;
    diffuseFood;
    updateFoodGradient;
    plotSystem(points+0.5);
    PLOT_TO_FILE
    ? plotToNextFile
    : begin
        addAnimationFrame;
        postDisplay;
      end;
    print(step,' - p/t: ',points.size,' +',multiply,' -',dieOff);
  end);

end;





