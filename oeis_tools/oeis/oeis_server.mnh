#!/usr/bin/mnh_light +out ?.log(1)
private datastore sequences:=[];
private datastore names    :=[];
private datastore foundImplementations:=[].toMap;
private datastore details  :=[].toMap;

fetchDetails(indexes:IntList)->indexes.map(::fetchDetails).join("\n");
fetchDetails(index:Int)->details[index] orElse begin
  local TRANS:=['%I'=>"Id  :\t",
        '%S'=>"Seq.:\t",
        '%T'=>" ...:\t",
        '%U'=>" ...:\t",
        '%N'=>"Name:\t",
        '%D'=>"Ref :\t",
        '%H'=>"Link:\t",
        '%F'=>"Frm.:\t",
        '%Y'=>"see :\t",
        '%A'=>"Author:\t",
        '%E'=>"Ext :\t",
        '%K'=>"Key :\t",
        '%C'=>"Comm:\t",
        '%O'=>"Off.:\t"];
  local data:=
  encodeRequest('https:','//oeis.org/search',['q'=>format('id:'&IDFormat,index),'fmt'=>'text'].toMap)
  .httpGet['body']
  .split("\n")
  .filter({$L.hasPrefix('%')})
  .map({[copy($L,0,2),copy($L,3).replace(["\t","\v","\r"],' ')]})
  .map({$x[0]='%I' ? $x : [$x[0],$x[1].copy(8)]})
  .map({(TRANS[$x[0]] orElse "\t") &$x[1]})
  .flatten
  .join("\n")
  .compress;
  details[index]:=data;
  data;
end;

ipcId:=myPath.extractFileNameOnly&format('%x',myPath.fileStats).join;

USE oeis_sequences;
memoized implementationOf(index:Int)->begin
  local result:=implemented[index];
  result.isVoid ? void : return result;
  result:=foundImplementations[index];
  result.isVoid ? void : return [result[0].toExpression,result[1]];
  result:=sequences[index];
  result.isVoid ? return void : void;
  result:=guessImplementation(result);
  result.isVoid ? return void : foundImplementations[index]:=result;
  print('Found new implementation [',index,'] ',result);
  [result[0].toExpression,result[1]];
end;

implementationOf(s:String)->begin
  local id:=s.clean(['0'..'9'],'').softCast;
  id.isInt ? implementationOf(id) : void;
end;

private memoized sevenZipExe->
  ["c:/Program Files/7-Zip/7z.exe",
   "c:/Program Files (x86)/7-Zip/7z.exe"]
  .each(file,file.fileExists ? file : void,head)
  orElse fail('7-Zip could not be located!');

private IDFormat:='A%6.6d';

private info(numericId:Int)->
  ['ID'      => IDFormat.format(numericId),
   'Name'    => names[numericId] orElse '- not found -',
   'Sequence'=> sequences[numericId] orElse [],
   'Info'    => classify(sequences[numericId] orElse []),
   implementationOf(numericId).isVoid ? void :
   ('genClass'=>implementationOf(numericId).map(::toString))
   ].toMap;

private top10(L:List)->top10(L.elementFrequency);
private top10(M:Map)->begin
  local X:=M.sort(1).trailing(10).reverseList;
  local factor:=50/X[0,1];
  X.map({format("\t\t%s\t%s\t%s",$x[0].join(","),$x[1],repeat('*',round($x[1]*factor)))})
   .join("\n")
   .format;
end;

private D(x0,   x0):=[1,0,0];
private D(x0,x1>x0):=[0,1,0];
private D(x0,x1<x0):=[0,0,1];
private CLASS(0,0,0)->'empty';
private CLASS(e,0,0)->'constant';
private CLASS(0,i,0)->'monotonically increasing';
private CLASS(e,i,0)->'increasing';
private CLASS(0,0,d)->'monotonically decreasing';
private CLASS(e,0,d)->'decreasing';
private CLASS(e,i,d)->'alternating';

private classify(L:IntList)->begin
  local last:=L[0];
  CLASS@(L.tail.each(x,D(last,last:=x),+) orElse [0,0,0]);
end;

private unzipWithOperation(filename:String,operation:Expression(1))->
  print('Unzipping ',filename) orElse
  mnhInfo['targetOs'].matches('(i?)Linux')
  ? 'zcat'     .teeExec([filename],operation)
  : sevenZipExe.teeExec(['e','-so','-bd',filename],operation);

private getData(URL:String,extractor:Expression(1))->begin
  local filename:=URL.split('/').trailing;
  (local fileExistedBefore:=fileExists(filename))
  ? void
  : begin
      print('Fetching data from ',URL);
      local data:=httpGet(URL);
      data['code']!=200 ? fail('Response from ',URL,' is ',data['code']) :
      print(filename,' downloaded');
      filename.writeFile(data['body']);
    end;
  local list:=[];
  local temp:=unzipWithOperation(filename,{list||=extractor($line)});
  temp[1]==0 ? print(filename,' decompressed')
             : fail('Decompression returned with exit code ',temp[1]);
  fileExistedBefore ? void : deleteFile(filename);
  temp[0];
  list.toMap;
end;

//*Updates datastores based on input files
//*Obtain the files at https://oeis.org/names.gz and https://oeis.org/stripped.gz
//*Unzip the files before using them as input
@SuppressUnusedParameterWarning
private memoized serve_('download',...)->begin
  local response:=[];
  local respond:={print@($params) orElse response|=join($params)};
  respond('Updating data - old: ',typeOf(names));
  local idAndRest  :={[$s.copy(1,6).softCast,$s.copy(8,$s.length)]};
  local idAndSeries:={[$s.copy(1,6).softCast,$s.copy(8,$s.length).split(',').softCast.filter(::isInt)]};
  local namesMap :=future(::getData,['https://oeis.org/names.gz'   ,{$line.matches('^A\d{6} ') ? idAndRest($line)   : void}]);
  //local namesMap :=         getData( 'https://oeis.org/names.gz'   ,{$line.matches('^A\d{6} ') ? idAndRest($line)   : void});
  local seriesMap:=         getData( 'https://oeis.org/stripped.gz',{$line.matches('^A\d{6} ') ? idAndSeries($line) : void});
  namesMap:=namesMap(); //resolve future
  respond('Files parsed - ',seriesMap.size,'/',namesMap.size,' entries');
  local maxSeries:=max(namesMap.getInner(0).max,seriesMap.getInner(0).max);
  respond('Updating names list of ',maxSeries,' relevant entries');
  names    :=rangeGenerator(0,maxSeries).pMap({namesMap [$i] orElse ''});
  respond('Updating sequences list of ',maxSeries,' relevant entries');
  sequences:=rangeGenerator(0,maxSeries).pMap({seriesMap[$i] orElse []});
  respond('Datastores generated - '&(names.size)&' entries');
  foundImplementations:=[].toMap;
  response;
end; //downloadData

private serve_('id'     ,...)->map(...,{$s.clean(['0'..'9'],'').softCast}).filter(::isInt).pMap(::info);
private serve_('details',...)->map(...,{$s.clean(['0'..'9'],'').softCast}).filter(::isInt).fetchDetails;
private serve_('name'   ,...)->
  ... .each(pattern,names.matches(pattern),or).indexOf.map(::info);

private mutable SEQ_AS_STRING:=void;
private synchronized getSeqAsString->SEQ_AS_STRING orElse begin
  SEQ_AS_STRING:=sequences.pMap(::toString);
  SEQ_AS_STRING;
end;

private serve_('part',part)->getSeqAsString.matches(part).indexOf.pMap(::info);
private serve_('continue',start:IntList,additional>0)->begin
  local matching:=sequences.pEach(seq,
    seq.head(start.size)==start
    ? [index,seq.tail(start.size).head(additional)]
    : void);
  matching.size=0
  ? 'No matches'
  : begin
      local parts:=[1..additional].pEach(s,matching.getInner(1).map({$seq.head(s)}).toSet.size);
      matching:=matching
        .group(1)
        .pEach(g,
          [g[1].size,
           g[1].head(10).getInner(0).pMap({format(IDFormat,$id)}).join(", ")&(g.size<=10 ? '' : '...'),
           g[0].join(",")])
        .sort(0);
     ((format("There are\t%s\tsequences starting with %s",matching.getInner(0).agg(+),start.join(","))|
       format("\t%{$1}s\tdifferent options for the next %{$0}s digit%{$0=1?'':'s'}s",[1..additional],parts)).join("\n").formatTabs|
       format("%{$x[0]}s\tentries (%{$x[1]}s)\n\tsay: %{$x[2]}s",matching.trailing(5).reverseList).join("\n").formatTabs).join("\n");
    end;
end;

VALIDATION_TIMEOUT_IN_SECONDS:=10;
private serve_('validate')->
  implemented.mergeMaps(foundImplementations,::orElse)
  .pMap({[$x[0],$x[1,0].isExpression ? $x[1,0] : $x[1,0].toExpression]})
  .sort
  .lazyMap({[$x[0],                                                     //ID
             timingOutGenerator($x[1](),VALIDATION_TIMEOUT_IN_SECONDS), //Generator
             sequences[$x[0]] orElse []]})                              //Expected value
  .futureMap({[$x[0],$x[1].head($x[2].size),$x[2]]})
  .map({note('Validating ',$x[0]) orElse
        ($x[1]==$x[2]
        ? [0,$x[0]]
        : $x[2]==[]
          ? [1,format("No sequence found for "&IDFormat,$x[0])]
          : $x[1]==$x[2].head($x[1].size)
            ? [2,'Validation for '&format(IDFormat,$x[0])&' timed out @'&($x[1].size-1)]
            : [3,'Validation for '&format(IDFormat,$x[0])&' failed @'&join(indexOf($x[1]!=$x[2]))])})
  .{$L.getInner(1).group($L.getInner(0))}
  .{begin
      ($L[0] orElse []).size&" sequences validated successfully\n"&
      $L[1].flatten.join("\n")&"\n"&
      $L[2].flatten.join("\n")&"\n"&
      $L[3].flatten.join("\n");
    end}.trim;

private serve_('statistics')->begin
 (sequences.size=0 ? 'No sequences' :
  begin
    local allNumbers:=sequences.flatten.toSet;
    join(["Largest  integer                                       : ",allNumbers.max,
        "\nSmallest positive integer not contained in any sequence: ",rangeGenerator(0,  2^60 ).filter({!($x in allNumbers)}).head(1).head,
        "\nLargest  negative integer not contained in any sequence: ",rangeGenerator(0,-(2^60)).filter({!($x in allNumbers)}).head(1).head,
        "\nSmallest integer                                       : ",allNumbers.min]);
  end&
  "\n\nMost frequent integers:\n"&(sequences.flatten.top10.formatTabs.join("\n"))&
  "\n\nSequence classifications:\n"&(sequences.pMap(::classify).elementFrequency.sort(1).map({'  '&($x.join("\t"))}).join("\n").formatTabs.join("\n"))&
  "\n\nMost frequent series lengths:\n"&
  begin
    local sizes:=sequences.pMap(::size);
    sizes.top10.formatTabs.join("\n")&
    "\nAverage series length: "&(sizes.agg(+)/sizes.size);
  end)&
  format("\n\nThere are implementations available for %s series ", implemented.mergeMaps(foundImplementations,{$0 orElse $1}).size);
end;

USE generators;
private serve_('gen',seriesId,count)->begin
  local seriesIdx:=seriesId.clean(['0'..'9'],'').softCast;
  local n:=count.softCast;
  n.isInt AND n>0 ? void : return 'Parameter '&escape(count)&' is no positive integer';
  seriesIdx.isInt and seriesIdx>0 ? void : return 'Parameter '&escape(seriesId)&' is no valid series id';
  local f:=implementationOf(seriesIdx);
  f.isVoid
  ? note('No implementation found - using fallback') orElse
    f:=toIteratableExpression(sequences[seriesIdx] orElse []) //if no implementation is found, pseudo generate based on stored list
  : f:=f[0]();
  f.head(n);
end;

private serve_('class')->implemented.mergeMaps(foundImplementations,::orElse).map({$x[1,1]}).elementFrequency.map({$x.join("\t")}).join("\n");
private serve_('class',className)->
  implemented.mergeMaps(foundImplementations,::orElse)
    .pMap({$entry[1,1]==className ? $entry[0] : void})
    .sort.pMap(::info);

private mutable timeout:=time+600;
private synchronized resetTimeout()->begin
  timeout:=time+600;
  void;
end;
private synchronized resetTimeout(x)->begin
  timeout:=time+600;
  print('Timeout set to ',formatTime('hh:mm:ss',systime+10/24/60));
  x;
end;

private serve_('scan')->begin
  foundImplementations:=
  sequences.pEach(seq,implemented[index].isVoid ? begin
    local imp:=try({guessImplementation(seq)},{fail('guessImplementation failed for ',index,"\n",$0.map({$x.join("\t")}).join("\n"))});
    imp.isVoid
    ? void
    : [index,imp,printf(IDFormat&'=%s',index,imp.toString)];
    end : void).toMap;
  resetTimeout(foundImplementations.size&' Implementations found');
end;

private serve_('duplicates')->
  sequences.each(seq,[index,seq]).group(1).pMap({$group.size>1 ? [$group.getInner(0).sort,$group[0,1]] : void})
  .sort(0)
  .each(g,
    "Sequence:\t",g[1]==[] ? "[]" : g[1].join(","),"\n",
    'Occurs ',g[0].size,"x:\t",IDFormat.format(g[0]).join(", "),"\n",&);

private serve_('numberFrequencies')->
  sequences.pMap({$seq[0<$seq<1E6]}).flatten.elementFrequency.sort.resetTimeout;

private serve_(...)->'Unkown command: '&toString(...);
serve(['stop'])->print('Stop signal received') orElse timeout:=time;
mutable serving:=false;
serve(parameters)->begin
  local t0:=time;
  print("Processing request: ",parameters);
  serving:=true;
  local result:=
  parameters.isList
    ? serve_@parameters
    : serve_(parameters);
  printf('Request: %s answered in %3.6fs',toString(parameters),time-t0);
  serving:=false;
  result.resetTimeout;
end;

@demo_for=Inter Process Communication, datastores
main()->begin
  startIpcServer(ipcId,::serve);
  print('IPC Server started. ',ipcId);
  while(serving OR time<timeout,sleep(1));
  print("\nIPC Server stopped. ",ipcId);
end;

