#!/usr/bin/mnh -GUI
USE collide_types,collide_initialState,collide_store;

private HAS_WRITE_ACCESS:=begin
  local MY_IPC_ID:=myPath+'1532';
  isIpcServerRunning(MY_IPC_ID)
  ? false
  : begin
      startIpcServer(MY_IPC_ID,::note);
      true;
    end;
end;

EDGE_HIT       :=-1;
POINT_HIT      :=-3;
GEOMETRY_HITS:=[EDGE_HIT,POINT_HIT];

//*Returns hit info: [hitTime,ballId,POINT_HIT,point]
ballHitsPoint(point:Vector,ballId:Int,p:Vector,v:Vector)->begin
  local dx:=p-point;
  // |p+v*t - point|=1
  // (p-point + v*t)^2=1
  // (p-point)^2 + 2*(p-point)*(v*t) + (v*t)^2 = 1
  (local xv:=(dx*v).agg(+))>=0.0 //ball is moving away from point
  ? return void
  : void;
  (local xx:=(dx*dx).agg(+))<=1.0 //point is in ball?
  ? return [0.0,ballId,POINT_HIT,point]
  : void;
  [(local a:=-xv/(local vv:=v.sqr.agg(+)))-sqrt(sqr(a)-(xx-1.)/vv),ballId,POINT_HIT,point];
end;

//*Returns hit Info: [hitTime,ballId,EDGE_HIT,edge]
ballHitsEdge(edge:EdgeSystem,ballId:Int,p:Vector,v:Vector)->begin
  local tp:=edge[1]*(p-edge[2]);
  -1<tp[1]<1 //is ball already intersecting or below ?
    ? 0<=tp[0]<=1 //is ball above edge
      ? [0.0,ballId,EDGE_HIT,edge]
      : void
    : (local vp:=edge[1]*v)[1]>=0 //is the ball moving away from the edge?
      ? void
      : begin
          local tHit:=(1-tp[1])/vp[1];
          tHit>0 AND 0<=tp[0]+vp[0]*tHit<=1 //will the ball be above the edge on hit time?
          ? [tHit,ballId,EDGE_HIT,edge]
          : void;
        end;
end;

ballHitsGeometry(geometryInfo:Geometry,ballId:Int,p:Vector,v:Vector,ballBox:BoundingBox)->
  (geometryInfo['edges'].pEach(edgeInfo,edgeInfo[4].boundingBoxesIntersect(ballBox) ? ballHitsEdge (edgeInfo,ballId,p,v) : void)) |
  (geometryInfo['nodes'].pEach(node    ,node       .pointIsInBox          (ballBox) ? ballHitsPoint(node    ,ballId,p,v) : void));

resolveGeometryHit(kind=POINT_HIT,hitInfo,position,velocity)->begin
  local dx:=position-hitInfo[3];
  dx/=dx.sqr.agg(+).sqrt;
  [(dx*1.00001+hitInfo[3]),
   velocity+dx*1.5*abs((dx*velocity).agg(+))];
end;

resolveGeometryHit(kind=EDGE_HIT,hitInfo,position,velocity)->begin
  local edgeSys:=hitInfo[3];
  local tp:=edgeSys[1]*(position-edgeSys[2]);
  local vp:=edgeSys[1]*velocity;
  vp[1]:=0.5*abs(vp[1]);
  tp[1]:=1.00001;
  [edgeSys[0]*tp+edgeSys[2],
   edgeSys[0]*vp];
end;

//*When do balls with position delta dx and speed delta dv collide?
private ballsCollide(dx:Vector,
                     dv:Vector,
                     ballId1:Int,ballId2:Int)->begin
  (local xv:=(dx*dv).agg(+))>=0.0 //Are balls moving away from each other?
  ? return void
  : void;
  (local xx:=(dx*dx).agg(+))<=4.0 //All balls already intersecting?
  ? return [0.0,ballId1,ballId2]
  : void;
  [(local a:=-xv/(local vv:=dv.sqr.agg(+)))-sqrt(sqr(a)-(xx-4.)/vv),ballId1,ballId2];
end;

movement(velocities)->velocities.each(v,v.sqr.agg(+),max).sqrt;

prettyStatus(collisionCount,sliceCount,movement)->begin
  local lineCounter:=0;
save;
  collisionCount=-1
  ? return lineCounter:=sliceCount;
  : void;
  lineCounter mod 20=0
  ? print('          step | collisions | time slices | max velocity')
  : void;
  printf('%9s %4s | %10s | %11s | %s',formatTime('hh:nn:ss ',systime),lineCounter+=1,collisionCount,sliceCount,movement);
end;


//*Evolve system of balls for a time step of dt
private evolve(geometry,positions,velocities)->begin
  local dtRest:=TIME_STEP_SIZE; //Remaining time to integrate
  local P:=positions;
  local V:=velocities.map({$v+[0.0,DOWNWARD_ACCEL*TIME_STEP_SIZE]});

  local maxDv:=V.each(v,sqr(v[0]),sqr(v[1]),V.head(index).each(u,(v-u).sqr.agg(+),max),max).sqrt+1E-10;
  local minDt:=     //Find smallest time step based on pairwise velocity differences
    min(max(1E-3/maxDv,5E-6),TIME_STEP_SIZE);

  local collisionCount:=0;
  local sliceCount:=0;

  while(dtRest>0,begin
    local ballBox:=P.pEach(p,boundingBoxOfBall(p,V[index],dtRest));
    sliceCount+=1;
    //Construct a list of collisions, sorted by time
    local collisions:=[0..P.size-1].pEach(j,
      j=0 ? void : [0..j-1].pEach(i,boundingBoxesIntersect(ballBox[i],ballBox[j]) ? ballsCollide(P[i]-P[j],V[i]-V[j],i,j) : void),
      ballHitsGeometry(geometry,j,P[j],V[j],ballBox[j]),|)
    .pFilter({$x[0]<=dtRest}).sort;
    //Find collision time (or none)
    local collisionTime:=max(min(collisions.head[0] orElse 1E50,dtRest),minDt);
    //Filter collisions to be considered in this time slice
    collisions:=collisions.filter({$x[0]<=collisionTime+minDt});
    //Integrate positions
    P+=collisionTime*V;
    dtRest-=collisionTime;
    collisionCount+=collisions.size;

    //Resolve collisions
    collisions.each(collision,begin
      local i:=collision[1];
      local j:=collision[2];
      j in GEOMETRY_HITS
      ? begin
          local R:=resolveGeometryHit(collision[2],collision,P[i],V[i]);
          P[i]:=R[0];
          V[i]:=R[1];
        end
      : begin
          //Resolve ball hit:
          local dx:=P[i]-P[j];
          local dn:=dx.sqr.agg(+).sqrt;
          dx:=dx/dn;
          //Negate differential velocity
          local dv:=V[i]-V[j]; dv:=dx*(dx*dv).agg(+);
          V[i]-=dv;
          V[j]+=dv;
          //move balls, so that they don't intersect anymore
          local cx:=0.5*(P[i]+P[j]);
          P[i]:=cx+(dx*=1.0001);
          P[j]:=cx-dx;
        end;
      void;
    end);
  end);
  prettyStatus(collisionCount,sliceCount,maxDv);
  [geometry,P,V];
end;

synchronized calculateOrReplaySystem(geometryName in (GEOMETRIES.getInner(0)),
                        ballPosName in (INITIAL_BALL_POSITIONS.getInner(0)),
                        numberOfBalls>=1,
                        cancelRequested:Expression(0))->
begin
  local name:=getInitialSystemName(geometryName,ballPosName,numberOfBalls);
  local sys:=void;
  doReplay(name)
  ? canResumeCalculation(name)
    ? begin
        print('Resuming calculation of ',name);
        sys:=resumeCalculation(name);
        prettyStatus(-1,current.size-2,-1);
      end
    : return true
  : begin
      print('Calculating ',name);
      sys:=getInitialSystem(geometryName,ballPosName,numberOfBalls);
      resetPlot;
      clearAnimation;
      storeInitial(sys[0],sys[1]);
      prettyStatus(-1,-1,-1);
      drawSystem@sys;
      postDisplay;
    end;
  while(stillMoving AND !cancelRequested(),
    begin
      sys:=evolve@sys;
      drawSystem@sys;
      storeStep(sys[1]);
    end);
  !cancelRequested() OR ask("Calculation cancelled\nDo you want to store the replay?",['Yes','No'])=='Yes'
  ? storeReplay(sys[2],name)
  : void;
  print('Done calculating');
  true;
end;


USE customFormUtil;

//*Interactive mode
main->begin
  local geometry:='simple';
  local layout:='stacked';
  local ballCount:=6;
  local ballCountTxt:=ballCount.toString;
  local runningTask:=async({true});
  local cancellingCalculation:=false;
  showDialog('Collide',[
    newComboBox({storedCollisions})
      .withCaption('Stored system')
      .withAction({begin
                     local parts:=$x.split(',').trim;
                     geometry :=parts[0];
                     layout   :=parts[1];
                     ballCount:=parts[2].softCast;
                     ballCountTxt:=ballCount.toString;
                   end}),
    newComboBox(GEOMETRIES.getInner(0).sort)
      .withCaption('Geometry')
      .bind(::geometry),
    newComboBox(INITIAL_BALL_POSITIONS.getInner(0).sort)
      .withCaption('Ball layout')
      .bind(::layout),
    newEdit
      .withCaption('Number of balls')
      .bind(::ballCountTxt)
      .withActionOnChange({ballCount:=$txt.softCast}),
    newSplitPanel([
    newButton
      .withCaption({collisions[getInitialSystemName(geometry,layout,ballCount)].isVoid
                    ? 'Calculate'
                    : getInitialSystemName(geometry,layout,ballCount).canResumeCalculation
                      ? 'Resume calculation'
                      : 'Replay'})
      .withEnabledRule({!runningTask().isVoid AND ballCount.isInt AND ballCount>=1 AND (HAS_WRITE_ACCESS OR !collisions[getInitialSystemName(geometry,layout,ballCount)].isVoid)})
      .withAction({begin
          cancellingCalculation:=false;
          runningTask:=localAsync(::calculateOrReplaySystem,[geometry,layout,ballCount,{cancellingCalculation}]);
        end})],[
    newButton
      .withCaption('Delete replay')
      .withEnabledRule({!collisions[getInitialSystemName(geometry,layout,ballCount)].isVoid AND HAS_WRITE_ACCESS})
      .withAction({collisions[getInitialSystemName(geometry,layout,ballCount)]:=void})
      ]),
    newOutputConsole,
    newButton.withCaption('Cancel calculation')
             .withAction({cancellingCalculation:=true})
             .withEnabledRule({!cancellingCalculation AND runningTask().isVoid})
  ]);
end;
