USE GUI,root,inspectionUtil;

ducktype FractionOfC(v:Numeric)->0<=v<=1;

@SuppressUnusedWarning
@Scenario=circling
@Frames=[0..99]/100*2*pi/$v
private SCENARIO_CIRCLING(speed:FractionOfC,pointInTime:Numeric)->
  [[{[ cos(($t+pointInTime)*speed), sin(($t+pointInTime)*speed)]}, 1],
   [{[-cos(($t+pointInTime)*speed),-sin(($t+pointInTime)*speed)]},-1]];

@SuppressUnusedWarning
@Scenario=double_circling
@Frames=[0..99]/100*2*pi/$v
private SCENARIO_DOUBLE_CIRCLING(speed:FractionOfC,pointInTime:Numeric)->
  [[{[ 2+cos(($t+pointInTime)*speed), sin(($t+pointInTime)*speed)]}, 1],
   [{[ 2-cos(($t+pointInTime)*speed),-sin(($t+pointInTime)*speed)]},-1],
   [{[-2-cos(($t+pointInTime)*speed), sin(($t+pointInTime)*speed)]},-1],
   [{[-2+cos(($t+pointInTime)*speed),-sin(($t+pointInTime)*speed)]}, 1]];

@SuppressUnusedWarning
@Scenario=atom
@Frames=[0..99]/100*2*pi/$v
private SCENARIO_ATOM(speed:FractionOfC,pointInTime:Numeric)->
  [[{[   0*$t,                                                0]}, 1],
   [{[-cos(($t+pointInTime)*speed),-sin(($t+pointInTime)*speed)]},-1]];

@SuppressUnusedWarning
@Scenario=encounter
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_ENCOUNTER(speed:FractionOfC,pointInTime:Numeric)->
  [[{[0, ($t+pointInTime)*speed]}, 1],
   [{[0,-($t+pointInTime)*speed]},-1]];

@SuppressUnusedWarning
@Scenario=diverge
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_DIVERGE(speed:FractionOfC,pointInTime:Numeric)->
  [[{[0, 2+($t+pointInTime)*speed]}, 1],
   [{[0,-2-($t+pointInTime)*speed]},-1]];

@SuppressUnusedWarning
@Scenario=flyby
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_FLYBY(speed:FractionOfC,pointInTime:Numeric)->
  [[{[ 1,0*$t                  ]}, 1],
   [{[-1,($t+pointInTime)*speed]},-1]];

@SuppressUnusedWarning
@Scenario=single
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_SINGLE(speed:FractionOfC,pointInTime:Numeric)->
  [[{[0,($t+pointInTime)*speed]},1]];

SCENARIOS:=
inspect['declares'].filter({!isVoid($rule.ruleAttributes['Scenario'])})
                   .map({$rule.ruleAttributes['Scenario']=>[$rule.getFunction,$rule.ruleAttributes['Frames']]})
                   .toMap;

WEATHER_FLAG_POSITIONS:=[-20..20].each(x,[-23..23].each(y,[x+(y and 1)*0.5,0.5*sqrt(3)*y]*0.4),|);

datastore storedWeatherFlags:=[].toMap;

apparentPosition(positionFunction:Expression(1),observerPosition:NumericList(2))->begin
  local t:=sqr(positionFunction(0)-observerPosition).agg(+).sqrt;
  positionFunction(-1*regulaFalsi({sqr(observerPosition-positionFunction(-$dt)).agg(+).sqrt-$dt},
                                     t-1,t+1,1E-3,1E-3));
end;

apparentPositions(scenario,observerPosition:NumericList(2))->
  scenario.each(charge,[apparentPosition(charge[0],observerPosition)-observerPosition,charge[1]]);

getWeatherFlagForces(scenarioName in (SCENARIOS.getInner(0)),speed:FractionOfC,pointInTime:Numeric)->begin
  local key:=[scenarioName,speed,pointInTime];
  storedWeatherFlags[key] orElse
  storedWeatherFlags[key]:=WEATHER_FLAG_POSITIONS.pEach(weatherFlagPosition,
    apparentPositions(SCENARIOS[scenarioName,0](speed,pointInTime),weatherFlagPosition).each(p,p[1]*p[0]*(p[0].sqr.agg(+)^(-1.5)),+));
end;

dist  (p:NumericList(2),q:NumericList(2))->sqr(p-q).agg(+).sqrt;
normed(x:NumericList)->x/(x.sqr.agg(+).sqrt);
arrow(x0:NumericList(2),x1:NumericList(2),maxTipSize)->begin
  local tipSize:=min(maxTipSize,dist(x1,x0)/2);
  local fwd:=x1-x0; fwd:=fwd.normed*tipSize;
  local lft:=[-fwd[1],fwd[0]];
  [x0,x1,x1-fwd-0.3*lft,x1,x1-fwd+0.3*lft,[Nan,Nan]];
end;

drawSystem(scenarioName in (SCENARIOS.getInner(0)),speed:FractionOfC,pointInTime:Numeric)->begin
  [['logscaleY',false],
   ['logscaleX',false],
   ['autoscaleX',false],
   ['autoscaleY',false],
   ['axisStyleX',0],
   ['axisStyleY',0],
   ['x0',-8],['x1',8],
   ['y0',-8],['y1',8]].toMap.setOptions;
  getWeatherFlagForces(scenarioName,speed,pointInTime)
  .pEach(fi,begin
    local p:=WEATHER_FLAG_POSITIONS[index];
    local f:=fi*0.18/max(0.02,fi.sqr.agg(+).sqrt);
    arrow(p-f,p+f,0.15);
  end,|).plot('0.5 black');
  SCENARIOS[scenarioName,0](speed,pointInTime)
    .each(c,(c[0](0)).map({[$x]})|((c[1]>0 ? 'red' : 'blue')&' . 2'))
    .map({addPlot@$x});
end;

createAnimation(scenarioName in (SCENARIOS.getInner(0)),speed:FractionOfC)->begin
  clearAnimation;
  SCENARIOS[scenarioName,1].toExpression()(speed)
  .each(pointInTime,begin
    drawSystem(scenarioName,speed,pointInTime);
    addAnimationFrame;
    index=0 ? display : void;
  end);
  display;
end;

prepeareAnimation(scenarioName in (SCENARIOS.getInner(0)),speed:FractionOfC)->begin
  SCENARIOS[scenarioName,1].toExpression()(speed)
  .each(pointInTime,begin
    getWeatherFlagForces(scenarioName,speed,pointInTime);
    void;
  end);
end;

//*Show animation for the given scenario and movement speed
//*Speed is fraction of c; 0.0<=speed<=1.0
main(scenario in (SCENARIOS.getInner(0)),speed)->createAnimation(scenario,toReal(speed));
//*Prepare animation for the given scenario and movement speed without displaying it
main('prepare',scenario in (SCENARIOS.getInner(0)),speed)->prepeareAnimation(scenario,toReal(speed));
//*List script parameters for cached scenarios
main('list')->
  storedWeatherFlags.getInner(0).map(::leading).unique.map({join(myPath.extractFileName|$x,' ').print});
