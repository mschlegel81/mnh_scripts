USE root,inspectionUtil;

ducktype FractionOfC(v:Numeric)->0<=v<=1;

@SuppressUnusedWarning
@Scenario=circling
@Frames=[0..99]/100*2*pi/$v
private SCENARIO_CIRCLING(speed:FractionOfC)->
  [[{[ cos($t*speed), sin($t*speed)]}, 1],
   [{[-cos($t*speed),-sin($t*speed)]},-1]];

@SuppressUnusedWarning
@Scenario=double_circling
@Frames=[0..99]/100*2*pi/$v
private SCENARIO_DOUBLE_CIRCLING(speed:FractionOfC)->
  [[{[ 2+cos($t*speed), sin($t*speed)]}, 1],
   [{[ 2-cos($t*speed),-sin($t*speed)]},-1],
   [{[-2-cos($t*speed), sin($t*speed)]},-1],
   [{[-2+cos($t*speed),-sin($t*speed)]}, 1]];

@SuppressUnusedWarning
@Scenario=quad_circling
@Frames=[0..99]/100*16*pi/$v
private SCENARIO_QUAD_CIRCLING(speed:FractionOfC)->
  [[{[-6+cos($t*speed  ),-6+sin($t*speed  )]}, 1],
   [{[-6-cos($t*speed  ),-6-sin($t*speed  )]},-1],
   [{[-6-cos($t*speed/2), 6+sin($t*speed/2)]},-1],
   [{[-6+cos($t*speed/2), 6-sin($t*speed/2)]}, 1],
   [{[ 6-cos($t*speed/4),-6+sin($t*speed/4)]},-1],
   [{[ 6+cos($t*speed/4),-6-sin($t*speed/4)]}, 1],
   [{[ 6-cos($t*speed/8), 6+sin($t*speed/8)]},-1],
   [{[ 6+cos($t*speed/8), 6-sin($t*speed/8)]}, 1]];

@SuppressUnusedWarning
@Scenario=atom
@Frames=[0..99]/100*2*pi/$v
private SCENARIO_ATOM(speed:FractionOfC)->
  [[{[   0*$t,0]}, 1],
   [{[-cos($t*speed),-sin($t*speed)]},-1]];

@SuppressUnusedWarning
@Scenario=anihilate
@Frames=[-150..50]/100*(8/$speed)
private SCENARIO_ANIHILATION(speed:FractionOfC)->
   [[{min(0,$t*speed)*[1.0,0.0]},1],
    [{min(0,$t*speed)*[0.70710678118654757,0.70710678118654746]},1],
    [{min(0,$t*speed)*[6.123233995736766E-17,1.0]},1],
    [{min(0,$t*speed)*[-0.70710678118654746,0.70710678118654757]},-1],
    [{min(0,$t*speed)*[-1.0,1.2246467991473532E-16]},-1],
    [{min(0,$t*speed)*[-0.70710678118654768,-0.70710678118654746]},-1],
    [{min(0,$t*speed)*[-1.8369701987210297E-16,-1.0]},-1],
    [{min(0,$t*speed)*[0.70710678118654746,-0.70710678118654768]},1]];

@SuppressUnusedWarning
@Scenario=condensator
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_CONDENSATOR(speed:FractionOfC)->
   [[{[ $t*speed,-3.5]}, 1],
    [{[-$t*speed,-2.5]},-1],
    [{[ $t*speed,-1.5]}, 1],
    [{[-$t*speed,-0.5]},-1],
    [{[ $t*speed, 0.5]}, 1],
    [{[-$t*speed, 1.5]},-1],
    [{[ $t*speed, 2.5]}, 1],
    [{[-$t*speed, 3.5]},-1]];

@SuppressUnusedWarning
@Scenario=diverge
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_DIVERGE(speed:FractionOfC)->
  [[{[0, $t*speed]}, 1],
   [{[0,-$t*speed]},-1]];

@SuppressUnusedWarning
@Scenario=flyby
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_FLYBY(speed:FractionOfC)->
  [[{[ 1,0*$t    ]}, 1],
   [{[-1,$t*speed]},-1]];

@SuppressUnusedWarning
@Scenario=single
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_SINGLE(speed:FractionOfC)->
  [[{[0,$t*speed]},1]];

@SuppressUnusedWarning
@Scenario=pair
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_PAIR(speed:FractionOfC)->
  [[{[ 0.5,$t*speed]}, 1],
   [{[-0.5,$t*speed]},-1]];

SCENARIOS:=
inspect['declares'].filter({!isVoid($rule.ruleAttributes['Scenario'])})
                   .map({$rule.ruleAttributes['Scenario']=>[$rule.getFunction,$rule.ruleAttributes['Frames']]})
                   .toMap;

WEATHER_FLAG_POSITIONS:=[-20..20].each(x,[-23..23].each(y,[x+(y and 1)*0.5,0.5*sqrt(3)*y]*0.4),|);
GRID_SIZE:=0.1;
GRID_POINTS:=
begin
  local X:=[0..ceil(16/GRID_SIZE)-1]*GRID_SIZE;
  X-=X.agg(+)/X.size;
  X.cross(X);
end;
GRID_BOXES:=GRID_POINTS.map({[$p-GRID_SIZE/2,$p+GRID_SIZE/2]});

datastore storedScenarios:=[].toMap;

apparentPosition(positionFunction:Expression(1),observerPosition:NumericList(2),atTime:Real)->begin
  local t:=sqr(positionFunction(atTime)-observerPosition).agg(+).sqrt;
  local tObserved:=atTime-regulaFalsi({euklideanNorm(observerPosition-positionFunction(atTime-$dt))-$dt},t-1,t+1,1E-3,1E-3);
  [positionFunction(tObserved     )-observerPosition,
   positionFunction(tObserved+1E-3)-observerPosition];
end;

apparentPositions(scenario,observerPosition:NumericList(2),atTime:Real)->
  scenario.each(charge,
               apparentPosition(charge[0],observerPosition,atTime)|charge[1]);

getCalculatedScenario(scenarioName in (SCENARIOS.getInner(0)),speed:FractionOfC)->begin
  local key:=[scenarioName,speed];
  print('Restoring scenario ',key.join(" "));
  (storedScenarios[key] orElse
   storedScenarios[key]:=
   begin
    assertUniqueInstance;
    local startOfCalculation:=time;
    local scenarioAtSpeed:=SCENARIOS[scenarioName,0](speed);
    local pointsInTime:=SCENARIOS[scenarioName,1].toExpression()(speed);
    print('Calculating scenario ',key.join(" "),'; ',pointsInTime.size,' frames must be calculated');
    print(repeat("------------------------|",4));
    local progressDot:=round([1..100]*pointsInTime.size/100)-1;
    local scenarioData:=
    pointsInTime.pEach(t,begin
      index in progressDot ? printDirect('.') : void;
      local forces:=WEATHER_FLAG_POSITIONS
         .each(obsPos,apparentPositions(scenarioAtSpeed,obsPos,t)
                      .each(p,p[2]*p[0]/(p[0].euklideanNorm^3),+));
      local potentials:=GRID_POINTS
          .each(obsPos,begin
            local apPos:=apparentPositions(scenarioAtSpeed,obsPos,t);
            [apPos.each(p,p[2]     / p[0].euklideanNorm   ,+),
            (apPos.each(p,p[2]*p[0]/(p[0].euklideanNorm^3),+)-
             apPos.each(p,p[2]*p[1]/(p[1].euklideanNorm^3),+)).euklideanNorm.*(1E3).sqrt];
           end).transpose;
      [forces       .map({$f.isNan.agg(or) OR $f.isInfinite.agg(or) ? [0,0] : $f}),
       potentials[0].map({$p.isNan         OR $p.isInfinite         ?  0    : $p}),
       potentials[1].map({$p.isNan         OR $p.isInfinite         ?  0    : $p})];
    end);
    scenarioData.showVariable;
    print;
    local globalMaxForce    :=scenarioData.getInner(0).pMap({$x.map(::euklideanNorm)}).flatten    .sort;
    local globalMaxPotential:=scenarioData.getInner(1)                                .flatten.abs.sort;
    local globalMaxMagnetFld:=scenarioData.getInner(2)                                .flatten.abs.sort;
          globalMaxForce    :=globalMaxForce    [round(0.95*globalMaxForce    .size)];
          globalMaxPotential:=globalMaxPotential[round(0.95*globalMaxPotential.size)];
          globalMaxMagnetFld:=globalMaxMagnetFld[round(0.95*globalMaxMagnetFld.size)];
    scenarioData:=scenarioData.pEach(frameData,begin
      index in progressDot ? printDirect('.') : void;
      [frameData[0]./(globalMaxForce).map({round($f*18/max(1,$f.euklideanNorm))}),
       frameData[1].map({max(-globalMaxPotential,$x).min(globalMaxPotential)/globalMaxPotential*178}).round,
       frameData[2].map({min($x.isNan ? 0 : $x,globalMaxMagnetFld)/globalMaxMagnetFld*255}).round];
    end);
    print("\nCalculation done in ",time-startOfCalculation,' seconds');
    scenarioData.serialize.compress;
  end).decompress.deserialize;
end;

normed(x:NumericList)->x/x.euklideanNorm;

maxTipSize:=0.15;

memoized dArrow(dx:IntList(2))->begin
  local tipSize:=min(maxTipSize,euklideanNorm(dx)/100);
  local fwd:=dx; fwd:=fwd.normed*tipSize;
  local lft:=[-fwd[1],fwd[0]];
  [-dx/100,
   +dx/100,
   +dx/100-fwd-0.3*lft,
   +dx/100,
   +dx/100-fwd+0.3*lft,
   [Nan,Nan]].transpose;
end;

arrow(xc:NumericList(2),dx:IntList(2))->(dArrow(dx)+xc).transpose;

memoized int_styleOfRelativePotential(i:Int)->'box fs 0 RGB'& join((i>0 ? [1,0,0] : [0,0,1])*abs(i/178)*0.7+[1,1,1]*(1-0.7*abs(i/178)),',');
memoized int_styleOfRelativeMagnetic (i:Int)->'box fs 0 RGB'& join([1,0.5,0]*i/255+[1,1,1]*(1-i/255),',');

showAnimation(scenarioName in (SCENARIOS.getInner(0)),speed:FractionOfC,magnetic:Boolean)->begin
  [['logscaleY',false],
   ['logscaleX',false],
   ['autoscaleX',false],
   ['autoscaleY',false],
   ['axisStyleX',0],
   ['axisStyleY',0],
   ['x0',-8],['x1',8],
   ['y0',-8],['y1',8]].toMap.setOptions;
  clearAnimation;
  local calculatedScenario:=getCalculatedScenario(scenarioName,speed);
  local actualPositions   :=begin
    local scenarioForSpeed:=SCENARIOS[scenarioName,0](speed);
    SCENARIOS[scenarioName,1]
      .toExpression()(speed)
      .each(t,scenarioForSpeed.map({[$s[0](t),sign($s[1])]})
                              .group(1)
                              .each(g,[g[1].getInner(0),(g[0]>0 ? 'red' : 'blue')&' . 2',
                                [g[0]>0 ? '+' : '-' ,
                                 8,//size
                                 'C',
                                 'Courier New',
                                 [1,1,1]]]));
  end;
  calculatedScenario.each(frameData,begin
    printDirect("\rRendering frame ",index,'/',size(calculatedScenario),'  ');
    plot();
    magnetic
    ?  GRID_BOXES.group(frameData[2])
      .each(g,g[0]=0 ? void : addPlot(g[1].each(hexagon,hexagon,[Nan,Nan],|),int_styleOfRelativeMagnetic (g[0])))
    :  GRID_BOXES.group(frameData[1])
      .each(g,g[0]=0 ? void : addPlot(g[1].each(hexagon,hexagon,[Nan,Nan],|),int_styleOfRelativePotential(g[0])));
    [WEATHER_FLAG_POSITIONS,frameData[0]].transpose.each(p,arrow@p,|)
    .addPlot('0.9 black');
    actualPositions[index].map({addPlot@head($x,2)});
    actualPositions[index].each(charge,
      charge[0].each(p,drawText@(p|charge[2])));

    addAnimationFrame;
    index=0 ? postDisplay : void;
  end);

  print;
end;

//*Show animation for the given scenario and movement speed
//*Speed is fraction of c; 0.0<=speed<=1.0
main(scenario in (SCENARIOS.getInner(0)),speed)->showAnimation(scenario,toReal(speed),false);
//*Show animation for the given scenario and movement speed
//*Display magnetic field strength instead of electric potential
main(scenario in (SCENARIOS.getInner(0)),speed,'m')->showAnimation(scenario,toReal(speed),true);

//*Prepare animation for the given scenario and movement speed without displaying it
main('prepare',scenario in (SCENARIOS.getInner(0)),speed)->getCalculatedScenario(scenario,speed);
//*List script parameters for cached scenarios
main('list')->
  storedScenarios.getInner(0).sort.map({join(myPath.extractFileName|$x,' ').print});
//*Initialize defaults
main('defaults')->
  begin
    print('INITIALIZING DEFAULT SCENARIOS');
    SCENARIOS.getInner(0).cross([0.5,0.9]).each(param,begin
      getCalculatedScenario@param;
      writeDataStores;
    end);
  end;
//*Delete a specific scenario
main('delete',scenario,speed)->begin storedScenarios[[scenario,speed.toReal]]:=void; end;


