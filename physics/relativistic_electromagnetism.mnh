USE inspectionUtil;

ducktype FractionOfC(v:Numeric)->0<=v<=1;

@SuppressUnusedWarning
@Scenario=circling
@Frames=[0..99]/100*2*pi/$v
private SCENARIO_CIRCLING(speed:FractionOfC)->
  [[{[ cos($t*speed), sin($t*speed)]}, 1],
   [{[-cos($t*speed),-sin($t*speed)]},-1]];

@SuppressUnusedWarning
@Scenario=double_circling
@Frames=[0..99]/100*2*pi/$v
private SCENARIO_DOUBLE_CIRCLING(speed:FractionOfC)->
  [[{[ 2+cos($t*speed), sin($t*speed)]}, 1],
   [{[ 2-cos($t*speed),-sin($t*speed)]},-1],
   [{[-2-cos($t*speed), sin($t*speed)]},-1],
   [{[-2+cos($t*speed),-sin($t*speed)]}, 1]];

@SuppressUnusedWarning
@Scenario=quad_circling
@Frames=[0..99]/100*16*pi/$v
private SCENARIO_QUAD_CIRCLING(speed:FractionOfC)->
  [[{[-6+cos($t*speed  ),-6+sin($t*speed  )]}, 1],
   [{[-6-cos($t*speed  ),-6-sin($t*speed  )]},-1],
   [{[-6-cos($t*speed/2), 6+sin($t*speed/2)]},-1],
   [{[-6+cos($t*speed/2), 6-sin($t*speed/2)]}, 1],
   [{[ 6-cos($t*speed/4),-6+sin($t*speed/4)]},-1],
   [{[ 6+cos($t*speed/4),-6-sin($t*speed/4)]}, 1],
   [{[ 6-cos($t*speed/8), 6+sin($t*speed/8)]},-1],
   [{[ 6+cos($t*speed/8), 6-sin($t*speed/8)]}, 1]];

@SuppressUnusedWarning
@Scenario=atom
@Frames=[0..99]/100*2*pi/$v
private SCENARIO_ATOM(speed:FractionOfC)->
  [[{[   0*$t,0]}, 1],
   [{[-cos($t*speed),-sin($t*speed)]},-1]];

@SuppressUnusedWarning
@Scenario=anihilate
@Frames=[-150..50]/100*(8/$speed)
private SCENARIO_ANIHILATION(speed:FractionOfC)->
   [[{min(0,$t*speed)*[1.0,0.0]},1],
    [{min(0,$t*speed)*[0.70710678118654757,0.70710678118654746]},1],
    [{min(0,$t*speed)*[6.123233995736766E-17,1.0]},1],
    [{min(0,$t*speed)*[-0.70710678118654746,0.70710678118654757]},-1],
    [{min(0,$t*speed)*[-1.0,1.2246467991473532E-16]},-1],
    [{min(0,$t*speed)*[-0.70710678118654768,-0.70710678118654746]},-1],
    [{min(0,$t*speed)*[-1.8369701987210297E-16,-1.0]},-1],
    [{min(0,$t*speed)*[0.70710678118654746,-0.70710678118654768]},1]];

@SuppressUnusedWarning
@Scenario=condensator
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_CONDENSATOR(speed:FractionOfC)->
   [[{[ $t*speed,-3.5]}, 1],
    [{[-$t*speed,-2.5]},-1],
    [{[ $t*speed,-1.5]}, 1],
    [{[-$t*speed,-0.5]},-1],
    [{[ $t*speed, 0.5]}, 1],
    [{[-$t*speed, 1.5]},-1],
    [{[ $t*speed, 2.5]}, 1],
    [{[-$t*speed, 3.5]},-1]];

@SuppressUnusedWarning
@Scenario=diverge
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_DIVERGE(speed:FractionOfC)->
  [[{[0, $t*speed]}, 1],
   [{[0,-$t*speed]},-1]];

@SuppressUnusedWarning
@Scenario=flyby
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_FLYBY(speed:FractionOfC)->
  [[{[ 1,0*$t    ]}, 1],
   [{[-1,$t*speed]},-1]];

@SuppressUnusedWarning
@Scenario=moving_pair
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_MOVING_PAIR(speed:FractionOfC)->
  [[{[ 0.25*sin($t*speed*2),$t*speed*0.866]}, 1],
   [{[-0.25*sin($t*speed*2),$t*speed*0.866]},-1]];

@SuppressUnusedWarning
@Scenario=single
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_SINGLE(speed:FractionOfC)->
  [[{[0,$t*speed]},1]];

@SuppressUnusedWarning
@Scenario=pair
@Frames=[-100..100]/100*(8/$speed)
private SCENARIO_PAIR(speed:FractionOfC)->
  [[{[ 0.5,$t*speed]}, 1],
   [{[-0.5,$t*speed]},-1]];

SCENARIOS:=
inspect['declares'].filter({!isVoid($rule.ruleAttributes['Scenario'])})
                   .map({$rule.ruleAttributes['Scenario']=>[$rule.getFunction,$rule.ruleAttributes['Frames']]})
                   .toMap;

WEATHER_FLAG_POSITIONS:=[-20..20].each(x,[-23..23].each(y,[x+(y and 1)*0.5,0.5*sqrt(3)*y]*0.4),|);
GRID_SIZE:=0.1;
GRID_POINTS:=
begin
  local X:=[0..ceil(16/GRID_SIZE)-1]*GRID_SIZE;
  X-=X.agg(+)/X.size;
  X.cross(X);
end;
GRID_BOXES:=GRID_POINTS.map({[$p-GRID_SIZE/2,$p+GRID_SIZE/2]});

datastore storedScenarios:=[].toMap;

USE root;

//*Find apparent positions by Regula Falsi
//*Solve: |p(t-dt)-p_obs| - dt = 0 for dt
apparentPosition(positionFunction:Expression(1),observerPosition:NumericList(2),atTime:Real,speed:Real)->begin
  //Solve: |p(t-dt)-p_obs| = dt
  //       |p(t-dt)-p_obs| - dt = 0
  //Corner case 1: Moving directly towards observer
  //|p(t-dt)-p_obs| - dt = dx(0)-v*dt-dt
  //                     = dx(0)+(-v-1)*dt = 0
  //               dx(0) = (v+1)*dt
  //                  dt =  dx(0)/(1+v)
  //Corner case 1: Moving directly away from observer
  //|p(t-dt)-p_obs| - dt = dx(0)+v*dt-dt
  //                     = dx(0)+(v-1)*dt = 0
  //               dx(0) = (1-v)*dt
  //                  dt =  dx(0)/(1-v)
  local t0:=       euklideanNorm(positionFunction(atTime   )-observerPosition);
  t0:=regulaFalsi({euklideanNorm(positionFunction(atTime-$t)-observerPosition)-$t},
                  t0/(1+speed),
                  t0/(1-speed),
                  1E-2,
                  1E-2);
  print(positionFunction);
  [positionFunction(atTime-t0     )-observerPosition,
   positionFunction(atTime-t0+1E-3)-observerPosition];
end;

apparentPositions(scenario,observerPosition:NumericList(2),atTime:Real,speed:Real)->
  scenario.each(charge,apparentPosition(charge[0],observerPosition,atTime,speed)|charge[1]);

dataToStore(data)->begin
  local previousFrame:=[WEATHER_FLAG_POSITIONS.map({[0,0]}),
                        GRID_POINTS.map({0}),
                        GRID_POINTS.map({0})];
  data.each(frame,begin
    local curr:=frame-previousFrame;
    previousFrame:=frame;
    curr;
  end).transpose.serialize.compress(1);
end;

storeToData(stored:String)->begin
  local previousFrame:=[WEATHER_FLAG_POSITIONS.map({[0,0]}),
                        GRID_POINTS.map({0}),
                        GRID_POINTS.map({0})];
  stored.decompress.deserialize.transpose.each(d,previousFrame+=d);
end;

getCalculatedScenario(scenarioName in (SCENARIOS.getInner(0)),speed:FractionOfC)->begin
  local key:=[scenarioName,speed];
  print('Restoring scenario ',key.join(" "));
  (storedScenarios[key] orElse
   storedScenarios[key]:=
   begin
    assertUniqueInstance;
    local startOfCalculation:=time;
    local scenarioAtSpeed:=SCENARIOS[scenarioName,0](speed);
    local pointsInTime:=SCENARIOS[scenarioName,1].toExpression()(speed);
    print('Calculating scenario ',key.join(" "),'; ',pointsInTime.size,' frames must be calculated');
    print(repeat("-",pointsInTime.size-1),'|');
    local scenarioData:=
    pointsInTime.pEach(t,begin
      local forces:=WEATHER_FLAG_POSITIONS
         .each(obsPos,apparentPositions(scenarioAtSpeed,obsPos,t,speed)
                      .each(p,p[2]*p[0]/(p[0].euklideanNorm^3),+));
      local potentials:=GRID_POINTS
          .each(obsPos,begin
            local apPos:=apparentPositions(scenarioAtSpeed,obsPos,t,speed);
            [apPos.each(p,p[2]     / p[0].euklideanNorm   ,+),
            (apPos.each(p,p[2]*p[0]/(p[0].euklideanNorm^3),+)-
             apPos.each(p,p[2]*p[1]/(p[1].euklideanNorm^3),+)).euklideanNorm.sqrt];
           end).transpose;
      [forces       .map({$f.isNan.agg(or) OR $f.isInfinite.agg(or) ? [0,0] : $f}),
       potentials[0].map({$p.isNan         OR $p.isInfinite         ?  0    : $p}),
       potentials[1].map({$p.isNan         OR $p.isInfinite         ?  0    : $p}),
       printDirect('.')];
    end);
    print;
    local globalMaxForce    :=scenarioData.getInner(0).pMap({$x.map(::euklideanNorm)}).flatten    .sort;
    local globalMaxPotential:=scenarioData.getInner(1)                                .flatten.abs.sort;
    local globalMaxMagnetFld:=scenarioData.getInner(2)                                .flatten.abs.sort;
          globalMaxForce    :=globalMaxForce    [round(0.90*globalMaxForce    .size)];
          globalMaxPotential:=globalMaxPotential[round(0.95*globalMaxPotential.size)];
          globalMaxMagnetFld:=globalMaxMagnetFld[round(0.95*globalMaxMagnetFld.size)];
    scenarioData:=scenarioData.pEach(frameData,begin
      [frameData[0]./(globalMaxForce).map({round($f*18/max(1,$f.euklideanNorm))}),
       frameData[1].map({max(-globalMaxPotential,$x).min(globalMaxPotential)/globalMaxPotential*178}).round,
       frameData[2].map({                    min($x     ,globalMaxMagnetFld)/globalMaxMagnetFld*255}).round,
       printDirect('.')];
    end);
    print("\nCalculation done in ",time-startOfCalculation,' seconds');
    scenarioData.dataToStore;
  end).storeToData;
end;

normed(x:NumericList)->x/x.euklideanNorm;

maxTipSize:=0.15;

memoized dArrow(dx:IntList(2))->begin
  local tipSize:=min(maxTipSize,euklideanNorm(dx)/100);
  local fwd:=dx; fwd:=fwd.normed*tipSize;
  local lft:=[-fwd[1],fwd[0]];
  [-dx/100,
   +dx/100,
   +dx/100-fwd-0.3*lft,
   +dx/100,
   +dx/100-fwd+0.3*lft,
   [Nan,Nan]].transpose;
end;

arrow(xc:NumericList(2),dx:IntList(2))->(dArrow(dx)+xc).transpose;

memoized int_styleOfRelativePotential(i:Int)->'box fs 0 RGB'& join((i>0 ? [1,0,0] : [0,0,1])*abs(i/178)*0.7+[1,1,1]*(1-0.7*abs(i/178)),',');
memoized int_styleOfRelativeMagnetic (i:Int)->'box fs 0 RGB'& join([1,0.5,0]*i/255+[1,1,1]*(1-i/255),',');

showAnimation(scenarioName in (SCENARIOS.getInner(0)),speed:FractionOfC,magnetic:Boolean)->begin
  [['logscaleY',false],
   ['logscaleX',false],
   ['autoscaleX',false],
   ['autoscaleY',false],
   ['axisStyleX',0],
   ['axisStyleY',0],
   ['x0',-8],['x1',8],
   ['y0',-8],['y1',8]].toMap.setOptions;
  clearAnimation;
  local calculatedScenario:=getCalculatedScenario(scenarioName,speed);
  local actualPositions   :=begin
    local scenarioForSpeed:=SCENARIOS[scenarioName,0](speed);
    SCENARIOS[scenarioName,1]
      .toExpression()(speed)
      .each(t,scenarioForSpeed.map({[$s[0](t),sign($s[1])]})
                              .group(1)
                              .each(g,[g[1].getInner(0),(g[0]>0 ? 'red' : 'blue')&' . 2',
                                [g[0]>0 ? '+' : '-' ,
                                 8,//size
                                 'C',
                                 'Courier New',
                                 [1,1,1]]]));
  end;
  calculatedScenario.each(frameData,begin
    printDirect("\rRendering frame ",index,'/',size(calculatedScenario),'  ');
    plot();
    magnetic
    ?  GRID_BOXES.group(frameData[2])
      .each(g,g[0]=0 ? void : addPlot(g[1].each(hexagon,hexagon,[Nan,Nan],|),int_styleOfRelativeMagnetic (g[0])))
    :  GRID_BOXES.group(frameData[1])
      .each(g,g[0]=0 ? void : addPlot(g[1].each(hexagon,hexagon,[Nan,Nan],|),int_styleOfRelativePotential(g[0])));
    [WEATHER_FLAG_POSITIONS,frameData[0]].transpose.each(p,arrow@p,|)
    .addPlot('0.9 black');
    actualPositions[index].map({addPlot@head($x,2)});
    actualPositions[index].each(charge,
      charge[0].each(p,drawText@(p|charge[2])));

    addAnimationFrame;
    index=0 ? postDisplay : void;
  end);

  print;
end;

//*Show animation for the given scenario and movement speed
//*Speed is fraction of c; 0.0<=speed<=1.0
main(scenario in (SCENARIOS.getInner(0)),speed)->showAnimation(scenario,toReal(speed),false);
//*Show animation for the given scenario and movement speed
//*Display magnetic field strength instead of electric potential
main(scenario in (SCENARIOS.getInner(0)),speed,'m')->showAnimation(scenario,toReal(speed),true);
//*Prepare animation for the given scenario and movement speed without displaying it
main('prepare',scenario in (SCENARIOS.getInner(0)),speed)->getCalculatedScenario(scenario,speed);
//*List script parameters for cached scenarios
main('list')->
  storedScenarios.size = 0
  ? print('No scenarios are stored')
  : storedScenarios.getInner(0).sort.map({join($x,' ').print});
//*Initialize defaults
main('defaults')->
  begin
    print('INITIALIZING DEFAULT SCENARIOS');
    SCENARIOS.getInner(0).cross([0.5,0.9]).each(param,begin
      getCalculatedScenario@param;
      writeDataStores;
    end);
  end;
//*Delete a specific scenario
main('delete',scenario,speed)->begin storedScenarios[[scenario,speed.toReal]]:=void; end;
