USE rungeKutta;

//*IMPORTANT: This Function must return an expression that allows vectorization!
makeForceFunction(range,strength)->[strength*16,'*(1-',range*0.5,'/$x)*(',range*0.5,'/$x-0.5)*ord($x<',range,')'].toExpression;

//Physics configuration:---------------------
WALL_FORCE_RANGE:=1;
WALL_POINT_SPACING:=0.2;
WALL_HEIGHT:=4;
absForce   :=makeForceFunction(1,1);
wallForce  :=makeForceFunction(WALL_FORCE_RANGE,5*WALL_POINT_SPACING);
DAMPING:=0.5;
GRAVITY:=1;
WIDTH_PARAM:=2;
//---------------------:Physics configuration

WALL_POINTS:=begin
  cross([-WIDTH_PARAM,WIDTH_PARAM],([1..ceil(WALL_HEIGHT/WALL_POINT_SPACING)])*WALL_POINT_SPACING).union(
  ([floor(-WIDTH_PARAM/WALL_POINT_SPACING)..ceil(WIDTH_PARAM/WALL_POINT_SPACING)]*WALL_POINT_SPACING).map({[$x,0]})).toList;
end;

memoized pairIndexes(listSize>1)->[0..listSize-2].each(i,[i+1..listSize-1].each(j,[i,j]),|);
         pairIndexes(0)->[];
memoized zeros(listSize>1)->[0..listSize-1]*0;
memoized gravAccel(listSize>1)->[0..listSize-1].map({[0,-GRAVITY]});

allWallForces(pointList:List)->pointList.pEach(p,begin
  local dirDist:=
  WALL_POINTS.each(q,begin
    (local n:=euklideanNorm(local d:=q-p))>WALL_FORCE_RANGE
    ? void
    : [d/n,n];
  end);
  dirDist.size=0
  ? [0,0]
  : (wallForce(dirDist.getInner(1))*dirDist.getInner(0)).agg(+);
end);

D(system:List(2))->begin
  local points:=system[0];
  local sysSize:=points.size;
  local nn:=pairIndexes(sysSize);
  local diffs:=points[nn.getInner(0)]-
               points[nn.getInner(1)];
  local dists :=diffs.map(::euklideanNorm);
  local forces:=absForce(dists)/dists*diffs;
  local A:=allWallForces(points)
           -DAMPING*system[1]
           +gravAccel(sysSize);
  nn.each(I,begin
    A[I[0]]-=forces[index];
    A[I[1]]+=forces[index];
    void;
  end);
  [system[1],A];
end;

timeStepForward:=integrator(CASH_KARP, //The Integrator
                            ::D,       //The ODE
                            0.05,      //time step size
                            1E-4);     //tolerance

plotSystem(points:List)->begin
  local y1:=void;
save;
  local y1_:=3;
  local balls:=
  points.each(p,begin
    local i:=index;
    local r:=points.each(q,i=index ? void : (q-p).euklideanNorm,min)
                   .min(2*abs(p[1]),
                        2*abs(p[0]-WIDTH_PARAM),
                        2*abs(p[0]+WIDTH_PARAM))/2;
    y1_:=max(y1_,p[1]+r);
    [p-r,p+r];
  end,|);
  y1.isVoid ? y1:=y1_: y1:=y1*0.9+y1_*0.1;
  setOptions(['y1'=>y1]);
  plot();
  balls.addPlot('RGB0.8,0.8,1 e fs 0.5');
  balls.addPlot('blue e 0.5');
  balls:=WALL_POINTS.each(p,p-0.5*WALL_POINT_SPACING,p+0.5*WALL_POINT_SPACING);
  balls.addPlot('RGB1,0.8,0.8 e fs 0.5');
  balls.addPlot('red e 0.5');

  addAnimationFrame;
end;

main(sampleCount)->begin
  local sys:=[0..toInt(sampleCount)-1].map({[random-0.5,1+0.5*$x]});
  sys:=[sys,zeros(sys.size)];


  setOptions(
   ['autoscaleFactor'=>1,
    'autoscaleX'=>false,
    'autoscaleY'=>false,
    'axisStyleX'=>3,
    'axisStyleY'=>3,
    'x0'=>-WIDTH_PARAM*1.01,
    'x1'=> WIDTH_PARAM*1.01,
    'y0'=>-2.0,
    'y1'=> 2.0,
    'logscaleX'=>false,
    'logscaleY'=>false,
    'preserveAspect'=>true]);

  clearAnimation;
  plotSystem(sys[0]);
  display;
  //while(true,
  [1..999].each(step,
  begin
    local t0:=time;
    sys:=sys.timeStepForward;
    //handle dropout
    local keepMask:=(sys[0].getInner(1)>-1);
    keepMask.agg(AND) ? void : begin
      sys[0]:=sys[0][keepMask];
      sys[1]:=sys[1][keepMask];
    end;

    printf('Time step done in %{time-t0}7.3fs');
    plotSystem(sys[0]);
  end);
  sys[0];
end;


