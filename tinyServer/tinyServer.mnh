#!C:\bin\mnh.exe -GUI -quiet +out ?.log(1)
USE tinyServer_html,tinyServer_config,loggingRunner;
private LOG_NAME:=changeFileExt(myPath,'.log');
//CPU Usage:--------------------------------------------------------------------------
mutable cpuUsageHistory:=[];

private getCpuDiagram->begin
  local shownFor:=[];
  local lastResult:='';
save;
  cpuUsageHistory==shownFor
  ? lastResult
  : begin
      shownFor:=cpuUsageHistory;
      setOptions(["preserveAspect"=>false,"axisStyleX"=>0,"axisStyleY"=>0].toMap);
      local x1:=max(cpuUsageHistory.size-1,1);
      plot(  [[0,0],  [x1,100]],'GREY0.13 fs box');
      cpuUsageHistory.size>0
      ? addPlot(cpuUsageHistory,'GREY0.5 f')
      : void;
      addPlot([[0,START_WHEN_WORKLOAD_BELOW],[x1,START_WHEN_WORKLOAD_BELOW]],'GREY0.5');
      drawTextAbsolute(0,0.5,'CPU',80,'L','Century Gothic',[0.2,0.2,0.2]);
      lastResult:= format('<img src="data:image/png;base64,%s" />',renderToString(500,100).base64encode);
    end;
end;

private isCpuAlmostIdle->(cpuUsageHistory.size>0) AND (cpuUsageHistory.trailing(SAMPLES_FOR_WORKLOAD_CHECK)<START_WHEN_WORKLOAD_BELOW).agg(AND);
//--------------------------------------------------------------------------:CPU Usage

private SPECIAL_TASK_RESTART:='RESTART';
datastore queued     :=[];
datastore history    :=[];

private enqueueTask(script,parameters)->begin
  queued|=[[systime,script,parameters]];
  writeDataStores;
end;

private statusSection->tag(
  ('Status').tag('h2')&htmlTable(
  [['Date:'  .tag('b'),formatTime('dd.mm.yyyy',      systime),''                ,htmlLink('restart server','restart')],
   ['Time:'  .tag('b'),formatTime('hh:nn:ss',        systime),''                ,htmlLink('show server log',encodeRequest('','displayFile',['filename'=>LOG_NAME].toMap))],
   ['Uptime:'.tag('b'),formatTime('hh:nn:ss',time/(24*60*60))]]),'div')&getCpuDiagram.join("<br>").tag('code');

private getQueuedSection(withLink:Boolean)->
  tag(
  tag('Queue'&(withLink ? '    '&htmlLink('(+)','enqueue') : void), 'h2')&
  htmlTable(
  [['Enqueued at','','Script','Parameters'].map({$x.tag('b')})] |
    queued.each(x,[formatTime('yyyy/mm/dd hh:nn:ss',x[0]),
                   htmlLink('remove','dequeue?index='&index),
                   x[1].tag('code'),
                   x[2].tag('code'),
                   htmlLink('force start','forceStart?index='&index),
                   index=0 ? '' :
                   htmlLink('move to front','moveToFront?index='&index)])),'div');

private getHistorySection->begin
  local runningScripts:=scriptRunning('query');
  tag(
  tag('History','h2')&
  htmlTable([['#','Executed','Script','Parameters','Log','Status'].map({$x.tag('b')})]|history.reverseList.map(
          {[$x[0],
            formatTime('yyyy/mm/dd hh:nn:ss',$x[1]),
            $x[2].tag('code'),
            $x[3].tag('code'),
            fileExists(getLogName($x[0])) ? htmlLink(getLogName($x[0]),encodeRequest('','displayFile',['filename'=>getLogName($x[0])].toMap)) : '- log missing -',
            (getLogName($x[0]) in runningScripts)
            ? tag('running ','b')
              & (getLogName($x[0]) in killRequests
                 ? tag('kill reqested','i')
                 : htmlLink('kill',encodeRequest('','kill',['index'=>$x[0]].toMap)))
            : getLogName($x[0]).isLogComplete
              ? 'finished'
              : 'cancelled'
            ]})),'div');
end;

private getNextTask->queued.size<=0 ? [] : begin
  local historyIndex:=history.getInner(0).max+1;
  local task:=queued.head;
  local scriptName  :=task[1];
  local scriptParams:=task[2];
  queued:=queued.tail;
  local historyEntry:=[historyIndex,systime,scriptName,scriptParams];
  history.size>=MAX_HISTORY_SIZE
  ? history:=history.tail|[historyEntry]
  : history|=             [historyEntry];
  writeAllDataStores;
  scriptName=SPECIAL_TASK_RESTART
  ? SPECIAL_TASK_RESTART
  : [getLogName(historyIndex),scriptName.fullScriptName.systemSpecificFilename,scriptParams];
end;
private nextTaskIsRestart->
  queued.size>0 AND queued[0,1]==SPECIAL_TASK_RESTART
  ? begin
      queued:=queued.tail;
      writeAllDataStores;
      true;
    end
  : false;

START_PAGE:='/index';
ENQUEUE_PAGE:='/enqueue';
servePath((START_PAGE),parameters:Map)->htmlPage('Server Overview',statusSection&getQueuedSection(true)&getHistorySection,true).wrapTextInHttp;
servePath('/restart',parameters)->begin
  enqueueTask(SPECIAL_TASK_RESTART,'');
  redirectTo(START_PAGE);
end;
servePath('/kill',parameters)->begin
  local indexToKill:=parameters['index'];
  indexToKill.isInt
  ? killRequests|=getLogName(indexToKill)
  : void;
  redirectTo(START_PAGE);
end;
servePath('/dequeue',parameters)->begin
  local indexToDrop:=parameters['index'];
  indexToDrop.isInt
  ? queued[indexToDrop]:=void
  : void;
  redirectTo(START_PAGE);
end;
USE javascriptUtils;
servePath((ENQUEUE_PAGE),parameters)->
  htmlPage('Enqueue task',
  '<FORM name="myForm">'&
  htmlLink('<<<'.htmlClean,START_PAGE)&
  getQueuedSection(false)&
  tag(
  tag('Enqueue task','h2')&htmlTable(
    filesInScriptFolder
    .each(script,[script.tag('code'),
             htmlLink('use','enqueue?scriptName='&script),
             htmlLink('show script',encodeRequest('','displayFile',['filename'=>script.fullScriptName].toMap))]))&
  jsHiddenInputFields(parameters).join&
  (parameters['scriptName'] orElse '----')&
  jsTextInputField('cmdLineParameters','',parameters,100)
  ,'div')&
  (parameters['scriptName'].isVoid ? void : '<br>'&htmlLink('enqueue task',http.encodeRequest('','addTask',parameters)))&
  tag(
  tag('Rerun previous','h2')&
  history.map({$x[[2,3]]})
       .unique
       .filter({$x[0]!=SPECIAL_TASK_RESTART AND fileExists(fullScriptName($x[0]))})
       .map({htmlLink($x.join(' ').tag('code'),encodeRequest('','addTask',['scriptName'=>$x[0],'cmdLineParameters'=>$x[1]].toMap))})
       .join("<br>")
   ,'div')
  &'</FORM>'
  ,false).wrapTextInHttp;

servePath('/addTask',parameters)->begin
  enqueueTask(parameters['scriptName'],
              parameters['cmdLineParameters'] orElse '');
  redirectTo(ENQUEUE_PAGE);
end;

servePath('/displayFile',parameters)->begin
  local filename:=parameters['filename'];
  isString(filename) AND fileExists(filename)
  ? begin
      filename==LOG_NAME ? logServeStats : void;
      fileContents(filename).wrapTextInHttp('text/plain');
    end
  : redirectTo(START_PAGE);
end;

servePath('/forceStart',parameters)->begin
  local indexToStart:=parameters['index'];
  isInt(indexToStart) AND (0<=indexToStart<queued.size)
  ? begin
      indexToStart=0
      ? void
      : queued:=queued[indexToStart|filter([0..queued.size-1],{$x<>indexToStart})];
      queued.size>0 AND queued[0,1]==SPECIAL_TASK_RESTART
      ? void
      : startExecution@getNextTask;
    end
  : void;
  redirectTo(START_PAGE);
end;

servePath('/moveToFront',parameters)->begin
  local indexToStart:=parameters['index'];
  isInt(indexToStart) AND (0<indexToStart<queued.size)
  ? begin
      queued:=queued[indexToStart|filter([0..queued.size-1],{$x<>indexToStart})];
    end
  : void;
  redirectTo(START_PAGE);
end;

servePath('/favicon.ico',parameters)->begin
  fileExists('favicon.ico')
  ? wrapTextInHttp(fileContents('favicon.ico'),'image/x-icon')
  : httpError;
end;

servePath(unknownPath,parameters)->begin
  warn('Unhandled path: ',unknownPath);
  redirectTo(START_PAGE);
end;

mutable serveStatistics:=[].toMap;

logServeStats->
    begin
      print('+---------------------------------- - - -');
      print('| Time ',formatTime(systime));
      print('| Uptime ',formatTime('hh:nn:ss',time/(24*60*60)));
      print('+---------------------------------- - - -');
      serveStatistics
        .map({$x[0]|$x[1]})
        .sort(2)
        .each(entry,print('Request: ',entry[0]),
                    printf(" served:\t%s\ttimes\n\t%s\tseconds (total)\n\t%s\tseconds (average)",entry[1],entry[2],entry[2]/entry[1]));
      serveStatistics.size>100
      ? serveStatistics:=[].toMap
      : void;
    end;

serve(M)->begin
  local path:=M['request','path'];
  local serveTime:=-time;
  local response:=
  servePath(path.extractPath,
            path.extractParameters);
  serveTime+=time;
  serveStatistics[path]:=(serveStatistics[path] orElse [0,0])+[1,serveTime];
  response;
end;

main->begin
  local logCpuUsage:={
  begin
    cpuUsageHistory|=exec('wmic',['path','Win32_PerfFormattedData_PerfOS_Processor','get','Name,','PercentProcessorTime'])[0]
                    .tail.filter({$x!=''}).map({$line.trim.replace('  ',' ').split(' ').softCast}).toMap['_Total'] orElse -1;
    cpuUsageHistory.size>1000
    ? cpuUsageHistory:=cpuUsageHistory.tail
    : void;
  end};
  local sinceLastTaskStart:=0;
  local restartScheduled:=false;
  begin
    local serverIsUp:=false;
    while(!serverIsUp,{begin
      startHttpServer(SERVE_AT_IP&':'&SERVE_AT_SOCKET,::serve,-1);
      serverIsUp:=true;
    end}.try({
    begin
      print('Failed to start server at ',SERVE_AT_IP,':',SERVE_AT_SOCKET,' - trying next');
      assert((SERVE_AT_SOCKET+=1)<=65535,'No valid socket found for IP ',SERVE_AT_IP);
    end}));
  end;
  print(systime.formatTime,' - server is up at ',SERVE_AT_IP&':'&SERVE_AT_SOCKET);
  while(!restartScheduled,begin
    logCpuUsage();
    nextTaskIsRestart
    ? restartScheduled:=true
    : (sinceLastTaskStart+=1)>=SAMPLES_FOR_WORKLOAD_CHECK AND isCpuAlmostIdle
      ? begin
          startExecution@getNextTask
          ? sinceLastTaskStart:=0
          : void;
          sleep(2);
        end
      : sleep(2);
  end);
  logServeStats;
end;

//@after
//restart->execAsync(executor,[myPath]);

